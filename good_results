 10:52
DONT FORGET: test 35 requires keyboard input A<cr>
initial state before any tests

ADDRESSES (hex)
pr:     60bb00
stack:  610980
vartab: 611320
----
STATE 1
parsing: <--end of line--
Var Table: name class type len (type)value
 empty
Stack (from top) class lvalue type stuff


BEGIN TESTING ALL

TEST 1  10:52
name in pr ->foobaaarwxyz<-
Var Table: name class type len (type)value
 var 0: foobaaaz 0 Int 1 pr[51]->0<-
 var 1: foobaaaz 0 Int 1 pr[55]->0<-
 var 2: foobaaaz 0 Int 1 pr[59]->0<-
 var 3: foobaaaz 0 Int 1 pr[63]->0<-
Test 1 done, error=0

TEST 2  10:52
name in pr ->foob5678<-
Var Table: name class type len (type)value
 var 0: foob5678 0 Int 1 pr[21]->0<-
 var 1: foob5678 0 Int 1 pr[25]->0<-
 var 2: foob5678 0 Int 1 pr[29]->0<-
 var 3: foob5678 0 Int 1 pr[33]->0<-
Test 2 done, error=0

TEST 3  10:52
name in pr ->foob<-
Var Table: name class type len (type)value
 var 0: foob 0 Int 1 pr[21]->0<-
 var 1: foob 0 Int 1 pr[25]->0<-
 var 2: foob 0 Int 1 pr[29]->0<-
 var 3: foob 0 Int 1 pr[33]->0<-
Test 3 done, error=0

TEST 4  10:52
name in pr ->foo(baaarwxyz<-
Var Table: name class type len (type)value
 var 0: foo 0 Int 1 pr[21]->0<-
 var 1: foo 0 Int 1 pr[25]->0<-
 var 2: foo 0 Int 1 pr[29]->0<-
 var 3: foo 0 Int 1 pr[33]->0<-
Test 4 done, error=0

TEST 5  10:52
symbol
fname,lname,cursor= 5 10 11
Test 5 done, error=0

TEST 6  10:52
Var Table: name class type len (type)value
 var 0: symbol 0 Char 1 pr[21]->NULL<-
pr ->char symbol, 34567890<-
pr ->23456789012345<-
Test 6 done, error=0

TEST 7  10:52
cursor->char symbol, more stuff
match,cursor= 1 4
cursor-> symbol, more stuff
match,cursor= 0 5
cursor->symbol, more stuff
Test 7 done, error=0

TEST 8  10:52
Var Table: name class type len (type)value
 var 0: a 0 Char 1 pr[101]->NULL<-
 var 1: b 1 Char 10 pr[102]-><-
 var 2: c 0 Char 1 pr[112]->NULL<-
 var 3: d 0 Int 1 pr[113]->0<-
 var 4: e 1 Int 10 pr[117]
 var 5: f 0 Int 1 pr[157]->0<-
Test 8 done, error=0

TEST 9  10:52
 empty case
Test 9 done, error=0

TEST 10  10:52
 empty case
Test 10 done, error=0

TEST 11  10:52
Stack (from top) class lvalue type stuff
 stack entry at 0: 0 A 2 pr[-6339321]

test 11, stack, popped val is 7
Test 11 done, error=0

TEST 12  10:52
nxtstack 0
after 4 pushes nxtstack 4
Stack (from top) class lvalue type stuff
 stack entry at 3: 1 A 2 pr[111]
 stack entry at 2: 0 A 2 pr[-6339251]
 stack entry at 1: 0 A 1 pr[611]
 stack entry at 0: 1 A 1 pr[555]-><-

begin 5 pops

first pop done:
 stack entry at 3: 1 A 2 pr[111]
array has 0 0 0 0 
 stack entry at 2: 0 A 2 pr[-6339251]
val = 77
 stack entry at 1: 0 A 1 pr[611]
val = c
 stack entry at 0: 1 A 1 pr[555]-><-
before 5th pop err: 0
nxtstack 0

after 5th pop err: 15
 stack entry at 0: 1 A 1 pr[555]-><-
Stack (from top) class lvalue type stuff

Test 12 done, error=15

TEST 13  10:52
at start cursor,epr,error = 1 35 0
cursor->}   {}   {{}{{}}}   {    STRING-END
4 skips: 
error,cursor = 0    {}   {{}{{}}}   {    STRING-END
error,cursor = 0    {{}{{}}}   {    STRING-END
error,cursor = 0    {    STRING-END
error,cursor = 0 D
Test 13 done, error=0

TEST 14  10:52
BEFORE rem()
cursor 0-->   

  /* a tiny-c style comment   
next-line  string-end
AFTER rem()
cursor 36-->next-line  string-end
Test 14 done, error=0

TEST 15  10:52
1 cursor->   17  "hello"  'c'  STRING-END<-
konst returns 2 17
2 cursor->  "hello"  'c'  STRING-END<-
konst returns 3 hello
3 cursor->  'c'  STRING-END<-
konst returns 1 c
4 cursor->  STRING-END<-
konst returns 0 
5 cursor->STRING-END<-
Test 15 done, error=0

TEST 16  10:52
pr->   17  "hello"  'c'  STRING-END
3 factor()'s
Stack (from top) class lvalue type stuff
 stack entry at 2: 0 A 1 pr[99]
 stack entry at 1: 1 A 1 pr[8]->hello<-
 stack entry at 0: 0 A 2 pr[-6339311]

3 popst()'s
 char c
 string hello
 int 17
Test 16 done, error=0

TEST 17  10:52
name in pr ->foobaaarwx<-
name in pr ->foob5678<-
name in pr ->foob<-
name in pr ->foo(baaarwxyz<-
Var Table: name class type len (type)value
 var 0: foobaaaz 11 Char 13 pr[10]
 var 1: foob5678 21 Int 23 pr[23]
 var 2: foob 31 Int 33 pr[115]
 var 3: foo 41 Char 43 pr[247]
look up foo
 var 3: foo 41 Char 43 pr[247]
look up foob5678
 var 1: foob5678 21 Int 23 pr[23]
look up foobaaaz
 var 0: foobaaaz 11 Char 13 pr[10]
Test 17 done, error=0

TEST 18  10:52
asgn returned 1, 1+2 is 3
asgn returned 1, 1+2+3 is 6
asgn returned 1, 1*2 is 2
asgn returned 1, (1+2)*3 is 9
Test 18 done, error=0

TEST 19  10:52
1<2 is 1 
1>2 is 0 
1==2 is 0 
1!=2 is 1 
1>=2 is 0 
1<=2 is 1 
2<2 is 0 
2>2 is 0 
2==2 is 1 
2!=2 is 0 
2>=2 is 1 
2<=2 is 1 
2<1 is 0 
2>1 is 1 
2==1 is 0 
2!=1 is 1 
2>=1 is 1 
2<=1 is 0 
Test 19 done, error=0

TEST 20  10:52
7+2 is 9 
7-2 is 5 
7*2 is 14 
7/2 is 3 
7%2 is 1 
Test 20 done, error=0

TEST 21  10:52
pr: char a; a='A'; 
Var Table: name class type len (type)value
 var 0: a 0 Char 1 pr[25]->NULL<-
Var Table: name class type len (type)value
 var 0: a 0 Char 1 pr[25]->A<-
Test 21 done, error=0

TEST 22  10:52
pr:  char a; int x; char p(7); xXXXXXXXXXXXXXXXXXXXXx
decl char a
prused,obsize 30 0 
20 63 68 61 72 20 70 28 37 29 3b 20 78 58 58 0 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 58 78 
decl int x
prused,obsize 34 0 
20 63 68 61 72 20 70 28 37 29 3b 20 78 58 58 0 0 0 0 0 58 58 58 58 58 58 58 58 58 58 58 58 58 78 
decl char p(7)
prused,obsize 42 0 
20 63 68 61 72 20 70 28 37 29 3b 20 78 58 58 0 0 0 0 0 0 0 0 0 0 0 0 0 58 58 58 58 58 78 
prused,obsize 42 0 
Test 22 done, error=0

TEST 23  10:52
pr:  int x; x=77;  xXXXXXXXXXXXXXXXXXXXXx
parsing int x;
78 58 58 0 0 0 0 58 58 58 58 58 58 58 58 58 58 58 58 58 58 78 
Var Table: name class type len (type)value
 var 0: x 0 Int 1 pr[18]->0<-
parsing x=77
78 58 58 4d 0 0 0 58 58 58 58 58 58 58 58 58 58 58 58 58 58 78 
Stack (from top) class lvalue type stuff

 x is 0
Test 23 done, error=14

TEST 24  10:52
pr:  int x(2); x(1)=77; xXX...XXXXXXXXXXXX...XXXXx
parsing int x(3);
78 58 58 2e 2e 2e 0 0 0 0 0 0 0 0 0 0 0 0 2e 2e 2e 58 58 58 58 78 
Var Table: name class type len (type)value
 var 0: x 1 Int 3 pr[26]
parsing x(1)=77;
78 58 58 2e 2e 2e 0 0 0 0 4d 0 0 0 0 0 0 0 2e 2e 2e 58 58 58 58 78 
Test 24 done, error=0

TEST 25  10:52
->M<- Back from MC('M',1);
Stack (from top) class lvalue type stuff

Test 25 done, error=0

TEST 26  10:52
TF
Test 26 done, error=0

TEST 27  10:52
 empty case
Test 27 done, error=0

TEST 28  10:52
 empty case
Test 28 done, error=0

TEST 29  10:52
o
Test 29 done, error=0

TEST 30  10:52
Test 30 (97):
/* test 30
[
MC('h',1);MC('e',1)
MC('l',1);MC('l',1);
MC('o',1);MC(' ',1);MC('t',1);MC('c',1);
]

applying st()...
hello tc
Test 30 done, error=0

TEST 31  10:52
Test 31 (125):
/* test 31
[
	int i;
	i=3;
	while(i)[
		MC(i,14);i=i-1;
	]
	if(i)[
		MC('T',1);MC(i,14)
	]
	else [
		MC('F',1);MC(i,14)
	]
]

applying st()...
321F0
Var Table: name class type len (type)value
 var 0: i 0 Int 1 pr[136]->0<-
Test 31 done, error=0

TEST 32  10:52
Var Table: name class type len (type)value
 var 0: foo 69 Int 1 pr[6]
parsing foo(77);
77
Test 32 done, error=0

TEST 33  10:52
Test 33 (46):
/* test 33
[
int a, b(0), c
char d, e(0), f
]

applying st()...

Var Table: name class type len (type)value
 var 0: a 0 Int 1 pr[57]->0<-
 var 1: b 1 Int 1 pr[61]
 var 2: c 0 Int 1 pr[65]->0<-
 var 3: d 0 Char 1 pr[69]->NULL<-
 var 4: e 1 Char 1 pr[70]-><-
 var 5: f 0 Char 1 pr[71]->NULL<-
Test 33 done, error=0

TEST 34  10:52
Test 34 (386):
/* test 34, link

/* put a single character
putchar char c [
	if(c==0)c='"'
	MC 1,c
]

/* put a block of chars from f to l inclusive
pft char f(0),l(0)[
	MC f,t,13
]

/* put a null terminated string
ps char b(0)[
	int k(0)
	k(0)=1
	pft(b, b-1+scann(b,b+30000, 0, k))
]

scann char f(0), l(0), c, int k [

] 

endlibrary

/* globals

int a, b(0), c
char d, e(0), f

main()[]

foobar()[]

applying link()...

fun table: fvar, lvar, prused
 fun entry at 0:  0 3 396
 fun entry at 1:  4 11 412
Var Table: name class type len (type)value
 var 0: putchar 69 Int 1 pr[51]
 var 1: pft 69 Int 1 pr[136]
 var 2: ps 69 Int 1 pr[201]
 var 3: scann 69 Int 1 pr[275]
 var 4: a 0 Int 1 pr[413]->0<-
 var 5: b 1 Int 1 pr[417]
 var 6: c 0 Int 1 pr[421]->0<-
 var 7: d 0 Char 1 pr[425]->NULL<-
 var 8: e 1 Char 1 pr[426]-><-
 var 9: f 0 Char 1 pr[427]->NULL<-
 var 10: main 69 Int 1 pr[369]
 var 11: foobar 69 Int 1 pr[381]
Test 34 done, error=0

TEST 35  10:52
t<--MC 1 echoed, and returns t
Test 35 done, error=0

TEST 36  10:52
charIn a abc is 1
charIn b abc is 2
charIn c abc is 3
charIn x abc is 0
Test 36 done, error=0

TEST 37  10:52
Seventy seven 77
Test 37 done, error=0

TEST 38  10:52
pr: -->[ MC("%d %s %d",11,"abc",33,101) ]  <--
 calling st();
11 abc 33
Test 38 done, error=0

TEST 39  10:52
empty case
Test 39 done, error=0

TEST 40  10:52
 empty case
Test 40 done, error=0

TEST 41  10:52
 empty case
Test 41 done, error=0

TEST 42  10:52
 empty case
Test 42 done, error=0

TEST 43  10:52
Hello, test  43
 testing pl,ps,pn,alpha,num,atoi
 should be 1 1 0 -> 1 1 0
num 77 has  2 digits
  and has value 77, and (atoi call) -77 value -77

Test 43 done, error=0

TEST 44  10:52
----tc system level, calling appl main

Hello, test  44
 testing ceqn, index, move
cat in hat

----tc system level, back from main
done

Test 44 done, error=0

TEST 45  10:52
----tc system level, calling appl main

whatHappened, INTENTIONAL ERROR...

app line 6 (cursor pr[3825])SYMERR, decl needed 
	  Kcount = 30;   /* <<== tab-tab-space-space K...
	       ^

Test 45 done, error=3

TEST 46  10:52
 empty case
Test 46 done, error=0

TEST 47  10:52
 empty case
Test 47 done, error=0

TEST 48  10:52
 empty case
Test 48 done, error=0

TEST 49  10:52
 empty case
Test 49 done, error=0

TEST 50  10:52
----tc system level, calling appl main

Hello, Application main
----tc system level, back from main
done

Test 50 done, error=0

TEST 51  10:52
----tc system level, calling appl main
hello tc
hello ps
hello pl. Seventy seven -->  77
----tc system level, back from main
done

Test 51 done, error=0

TEST 52  10:52
----tc system level, calling appl main

23456
----tc system level, back from main
done

Test 52 done, error=0

TEST 53  10:52
----tc system level, calling appl main

      b(3) is 123, b(1) is 123 
----tc system level, back from main
done

Test 53 done, error=0

TEST 54  10:52
----tc system level, calling appl main
ceqn cat cat, then cat dog
 1 0 should be 1 0
foo-bar-and-hello-to-you
foo-bar-and-hello-to-me
ceqn 20:  1 should be 1
ceqn 23:  0 should be 0
scann h:  12 0 should be 12 0
scann g:  11 0 should be 11 0

----tc system level, back from main
done

Test 54 done, error=0

TEST 55  10:52
----tc system level, calling appl main

app line 3 (cursor pr[3734])SYMERR, decl needed 
    error = on + purpose
        ^

Test 55 done, error=3

TEST 56  10:52
----tc system level, calling appl main
test 56: index
in ->the cat in the hat<- find cat:    5 should be 5
in ->the cat in the hat<- find dog:    0 should be 0

----tc system level, back from main
done

Test 56 done, error=0

TEST 57  10:52
----tc system level, calling appl main
cat in the hat .......
cat in the hat ..cat..
----tc system level, back from main
done

Test 57 done, error=0

TEST 58  10:52
----tc system level, calling appl main

health(2) should be 2, is 2
----tc system level, back from main
done

Test 58 done, error=0
