Notes.txt
Notes on reading these notes.
	I always keep a log, and I often use shorthand as a convenience. Here are some of my shorthands...
	~number means line number in a file, usually a code file but often this file.
	The 1977 8080 code is refered to by several names, TC.ASM, just ASM (not always upper case, 8080. 
	I note ISSUEs that I will work later with the all-caps word.
	When an issue is resolved, I leave it in the notes but break the word in two to avoid grep hits.
	Often I refer to specific C fcns by name(). The parens are just a flag "this is a fcn". I rarely use the full signature (all the args). And sometimes no () flag.
	
==================================	
I begin...

Aug 3, 2017
Starting from my own TC.ASM supplied by Lee Bradley, my plan is to clone it to my own C version that runs native on Unix, Linux, or wherever a C compiler exists. Goal is a GPS version so ANYONE can use it under gps rules.
---

Goal 1 -- variables, 
	newvar manages the var table. Called by valloc, which parses one variable behind INT or CHAR.
var table (called varb)
	fval,eval point to first and last of varb which itself is undeclared. ~65 has space allocs for this and other similar stuff. 

NEWVAR(class,size,len,passed) <= A,B,DE,HL; ~794
	capture args
	canon'd name -> varb
	class,size,len -> varb
	fval allocated in varb, ~817
		FVAL = next VARB address ~817
	[strings must be class 0???   ~820]
	~820 JZ NR2 for class 0. ~824 JNZ fall through to NR2 of 	PASSED. NR3 if PASSED.
	class 0 (string) or not passed as fcn arg needs value space -> NR2; else NR3
	if test ~818: class==0 || passed==0 ==>> NR2 get space
		values go in ++PRUSED -> KF (temp)
		fval->hl, prused->de (xchg), de->memory at fval
		prused += obsize*len
	alloc()...
		bump prused. Hold as KF. move to DE. 
		~829 get fval (temp DW ~791). loaded at ~817 with first unused byte into VARB. 5th column (value) of VAR table. PRUSED+1 is in DE ~825
		If passed, put that into value.	~855 NR3.
	Net effect is VARB points to first cell of allocated amount, and PRUSED is bumped to last cell of allocated. 
	Memory overflow test ~842 PRUSED > EPR.
	Zero the space ~850. 
	NR3 ~855 a passed arg is just put into VARB. 
	NR5 copy passed byte to allocated space BIT OF CLASS MYSTERY, HERE.
TO DO: fix bug noted in canon. Add allocation logic. Maybe add parsing logic.

VALLOC ~1360 VCLASS == 1 for array, else 0 ~1368. It gets loaded into A just before jmp to newvar ~1403.
VPASSED ~1356 ;0 for global or local, two byte value if param to function (comment in the code)
~1368   ;assume class 0 (not an array)
~1372 manage recursion, 79 call ASGN
~1398, V5, load registers with parms for NEWVAR. JMP call newvar. ~1407.

valloc logic
args: 
	type 'c' or 'i' for already parsed int or char.
	vpassed  probably not needed until we parse function calls
uses:
	symname: sets fname,lname
	lit for ( and )
	ASGN to parse the size
	TOPTOI to get ASGN result
	ESET to set symbol error (no sym ~)

logic:
	args, type in A, vpassed in HL (not used, passed
		through to NEWVAR)
	symname; err if none
x	vclass=0 ~1367
	if lit (
		[is array] ~1372: push fname,lname,vclass
		bump vclass 1377,1381
		expression ASGN -> stack ~1379
		pop vclass, lname, fname  ~1381
		test ASGN error ~1386
		lit ) ~1390
		toptoi -> alen  ~1394
	else [not array] ~1396, V3
		alen = 1
	endif
x	V5: oject size = 1 or 2 (type == 'c' or 'i' resp)
		-> B
	jmp-call newvar: A=class, B=objsize, DE=len, HL=vpassed
----
Aug 7 (Mon)
Started Thursday on this. Experience so far: Learning C all over. Learning to read 8080 asm code. Have to see the underlying intent, sometimes (as above valloc) taking notes.

Order of approach: originally thought I would do in chunk order. All global decs first, all math functions, etc. But that makes little sense. For example, I wont need math functions, and maybe not even char functions. So I am instead doing features from bottom (e.g. newvar which serves the name table) to parser (e.g. valloc). I am close to finishing those two. Couple of features needed in each level. Not allocating var space yet in newvar. Not tested valloc except ('C',0).

A brute force test engine is getting large. Probably need to split into test vs keeper code. And do a make file. Instead I have little scripts: c,t,ct,keep for compile, test, both, and move results from test to good for diff comparison. These seem reasonable make targets. 

Doing it feature-wise means for each feature a small parser, plus code to carry out whatever. A piece of front end with a PIECE of back end in one file. Integrating those resulting files should prove interesting.

Current major goal is DECL, test 101, only reachable via
   		$ ./a.out 101
These are outside the unit tests, from 1 to 
		equ testcases 6	  <- or whatever, the last one.

To finish decl...
	alloc()
		~819 if class is zero or if passed, alloc
		NR2 alloc code
		{
			~825 fval = kf = prused+1 
			~833 prused += obsize*len
			~841 if( prused-epr >=0 ) {eset(tmvl);return}
			~850 memset(kf,0,prused-kf+1)
		}
		NR3 is passed value code NOT DONE YET
x	decl() which parses 'int', 'char', and clauses behind
x	lit(), 
x	literals used by decl: xchar, xint, comma, semi
DONE
------------
NEXT GOAL: stack tools ~350
functions:
	int toptoi
	poptwo DEPRECATE
	popst ;pops the stack into A, B, C, DE. New top in HL.
		~394 -9 is compensating for 4 INX H's.
	pushone()  (PONE, 8080 name)
	pushzero() (PZERO, 8080 name)
	pushk(int) --  pushes a constant
	pushst(lots,,,)
		~413 increments by 5. the -9 must be a typo.
		3 calls to pushst in factor. none elsewhere
		dozens to pushk throught the parser. AND MC's.
Data structure (ref: POPST comments):
	in A,B,C,DE.
	class, lvalue, size, stuff
	~395: size is 5 bytes. 
	struct stGlob {int class; char lvalue ;int size ;int stuff; };
		and if lvalue=='L' use this way: (void*)stuff;
		Comment online: "void* is the same as char* except conversions to and from it do not require type casts" - also cannot add/subtract them. â€“ rsaxvc Apr 18 '15 at 22:33"
Comments:
	pushst, popst seem to be the basic. All others on top.
	~407 'A' is an lvalue code for actual. 
	~1293: CONFIRMED, Other code is probably 'L'. 
	WHATS IN DE when you do a PUSHK or PUSHST:
EQ (typical user)
	toptoi (stuff to be assigned -> DE); PUSH DE
	popst (must be an lvalue)
	if class>0 size=2 (instead of 1??)
	assure lvalue, else EQERR
	xchg
	POP DE   so ;where in HL ;stuff in DE
	MOV m,e and conditionally m+1,d
	push value back onto stack.   SO if lvalue=='L' stuff is either 
		int*, char*.  If 'A' it may also be int or char.
	*stGlob 
Wed, Aug 9 8:30pm
	wrote test 12. Need to put all test code at end, so it has decls from the keeper code. Need to add prints for the popped stuff, e.g. int array should have array2=stuff and print array2 content, and error code. Similar stuff for the other four pops.
Thur, 9:00 am.
	I want to split the file, and use make. Studying gcc options.
	DONE: Split, makefile, all seem to work. Anomoly is tc is a linux deep-deep-command, but ./tc is tiny-c. 
Fri, 11:30 am
	Found and fixed nasty and stupid bug. Called pushk instead of pushst with four args. Ran and pushed 4 stuff all as int. Anyway test 12 is ok, now. Stack tools are in pretty good shape.
	NEXT GOAL? asgn? Let's read.
	SKIP REM CONST FACTOR do these 4 first, then crawl up to ASGN.
	FACTOR  ~1169..1305 236 lines 8080 code
SKIP ~519..544 skips balanced l-r delimiters, assuming first l delimiter is 		matched. B,C have l,r chars respectively. counter in DE set to 1. 
REM ~660 in tc.asm, ~267 in tc.c. skips \n's and comments in any order.
rem seems to work. Test 14.
BUT test 8 results are OK for now, but will change when asgn done properly. 		THEN the two 9's will appear in the vartab dump.
AND to make newline stuff robust:
	1 - audit tc.asm for ALL places involved
	2 - rewrite to skip BOTH cr and lf in either order
CONST ;matches 3 kinds of constants, setting FNAME, LNAME as
;  in SYMNAME. Sets A to 0 on no match, 1,2,or 3 on match. does not evaluate, just parses.


How many places would 
	char* find(char x) 

be useful? Scan from cursor to epr for x and return pntr on success, else 0. No side effects, i.e. no change to cursor. Client has FULL control on effect. In C code so far...
	~158 ~198 ~272 symname lit rem (so far), and const big time. 
AND convienence form:
	char* mustfind(char x, int error_code) 

IMPROVEMENTs: 
	- eliminate global poptop, and return ptr to nxtstk+1 which still has popped data. BUT test design WARNING: a push will kill that data. If recursion does that, new function (oldTopToGlobal) to capture. Probably not an issue in practice. 
	- 

Sunday, 8/13. I need to set aside development for awhile, and clean up the test code.
	- get rid of pointers. Differences is ok, because they don't drift during development. printing the *ptr is ok.
	- print enough of test goal and init conditions and expected results to understand result without leaning on the test code.
	- Unify \n's in printf's. Do them ALL the same way. 
	- codify best practices into comments at top. Here, too.
Sunday night: did a survey (on paper) of where newlines are done. No conclusions yet. Most important test fix is to make pointers relative to their base, e.g. cursor-pr instead of cursor, thus making print contents stable and diffs reasonable.

---
Monday, 8/14. 
DONE Get a good_results that is known to be good AND STABLE.
---
resuming test cleanup. Have done tests 1-10, and 15.
TODO
	- newvar allocation
	- konst must null the trailing quote, tc.asm~609,CN3
	- Retrofit find's where useful.
	- poptop better way.
	- /* valloc: might use mustfind instead of lit. Needs study. */
	- resume FACTOR ~1167..1304

gdb
	set args 16
	b file:lineno
	b fcnName
	run
	s   into
	n   over
	bt  back trace (the stack)
	p expression


FWHERE is factor() where
WHERE is enter() where

~1237   ;class of element is one less than class of array. CAN class
be bigger? Does tc support array of arrays??? Where does class get incremented? NOWHERE as best I can tell. It is incrmented from 0 to 1 in VCLASS ~1377, but that increment code cannot be reached without passing through ~1367 which sets VCLASS to zero. 
---
Wed, Aug 16, Coded symname case of void factor(). Needs addrval().

ADDRVAL ~910 this is mature code that searches local,global,library segments of of the VAL table. I only need local, for now.

factor() compiles. 

AUDIT TO DO: push & pop stack, and newvar audit for use of union stuff.
Can we always PUSH the right stuff, and always POP also???
push:	 class==1 stuff.up  else size==0 stuff.uc  else stuff.ui
pop, or addrval: examine while in array, then pop and fetch stuff.x
	where x is the right stuff.

NEXT GOAL: write test 18, factor symname cases.

newval ~817, HL->fval ;address where fval will be put. 
NR7,4 allocates and zeros. 
NR3 passed value->stuff. 
NR5 ;if passed & class is 0 
	move the passed value into the allocated space.
NR6 update function table ???

---
Aug 28, back from Star Island. Today's goals: 
x	Reorder tc.c functions to same order as 8080 CPM listing. 
x	Bind handwritten notes for easy quick reference. 
x	MARK issues noted in the code.
x	MAKE tests solid, and document how to read each test result.
x	In test.c remove the if-elses and make ONE big switch.

Aug 29, 
	Still pointers in test results: stack entry, poptop
		stack entry at 3: 1 41 2 (>)-1188285840
		poptop: 1 41 2 -510876656
		could be wierd class,size data. Use meaningful data.
x	remove poptop and popst returns pointer into stack
x	examine usage of nxtvar and nxtstack and decide if change needed
x	3 uses of nxtvar. ~266, 413, 462, addrval, nxtvar, dumpVarTab. All
x	seem natural. Initializing to zero is also natural.
x	Ditto for nxtstack, push, pop, and dump.

IS SUE test.c ~60 or so. WHY is the client bumping nxtvar??? BECAUSE newvar is given a pointer to a var. It does not manage the table. It just fills data into the given var. Is that right? or wrong? Only two clients, valloc and enter. So leave it.

GOAL: Remove poptop. DONE

GOAL: quote in test 16. RESOLVED. Fix is in konst(). Test is proper.

Aug 30, Wednesday
Goals:
x	names of fcns into their chuncks. NOTE: math and other uneededs omitted.
x	entire expressions stack, asgn to konst.
x	st() plus support stuff (code entered, not tested yet)

Aug 31, Thursday, 8:30am
	st()  tested
	eq()  entered and tested along with st().
Tests can print stuff in the three data structures, var,stack,pr. So we put into pr a statement that effects var and stack, and then dump that structure. eq() would be a help, currently stubbed in a trivial way. And we cannot YET enter functions like ps. Before doing functions I want st() and eq() to be a firm foundation.
Gotta do BOTH skipst AND eq, and eq needs the value part of newvar to be debugged. Busy day, today.
9:30: st() compiles. Now type in skipst() and eq().
DIFFICULTY with using casts to immitate typeless. Found this...
	https://gist.github.com/buch415/8865157
which is a typeless structure using memcpy to just move bytes. Its data structure is trivial, it acts like a tape store, but the technique with a bit of direct access AND frames can exactly mimic 8080 values stored in pr after the code. 

Thought for eq(): suppose int x = 'c';  Then x has type 2 (int), 'c' has type 1 (char), And different sizes. Both class 0 though. eq() puts the 'c' into the value space of x. None of the attributes of x change. So 'c' is converted to type 2, sizeof(int), class 0. The attributes STAY WITH THE LVALUE. 
Another thought: The size attribute must be sizeof(char|int|char*). Type can be derived, type=size>1?int:char. Is that a good idea? Better to make 8080 size into type EVERYWHERE and derive size from class and type. 

DONE	Goal: change the size attribute to type, 1=char 2=int. And test nothing is broken. FIXED: (both) 7, dumpvartab heading.

Goal: function to compute size from class,type.

DONE: code before ShouldGet's in test.c

More thoughts. If you can assign anything to anything we have a size issue. The most common case is int x=<some char>, which can be useful. Less common is int x=<ptr> which has a size problem on 64 bit compiler. 
	pn(sizeof(char));pn(sizeof(int));pn(sizeof(char*));  output	148
Assigning a char* to an int loses a bunch. But somehow gcc loses nothing. See strange...c in ~/Doc*/Mint*.

Probably best is to allow it, and whatever happens happens. Keep the union thing for var and stackentry, but do memcpy's in and out of pr.

At eq() entry, the space is allocated. The variable OWNS a small bit of pr beyond the program. newvar should do that allocation. So start with newvar. Then eq.

Test 99, char took 2 bytes, int took 2 more.
type now has two meanings, actual 'A', char 1, int 2. And opposite of actual is lvalue 'L'. And sometimes the variable for lvalue is lvalue, i.e. same as type.
WHAT A MESS.
stackentry has both type and lvalue, var has type (and is always an lvalue), so they are consistent. It must be a local use of type where it should have been lvalue.
IS SUE valloc passed type = 'C'|'I'. THAT IS BETTER CODE than 1 or 2. enum? LATER
test 99 good. Above issues were bad test call on valloc, changed to decl and worked fine. newvar is allocating proper space and initing it to zero's.
Tomorrow we eq() a value into it and see by bytes change from 0's to that value. Here is the code from newvar (comments added). Note this will init a whole array of len data.
		char* kf;
		kf = prused+1;  				/* gotta zero starting here */
		(*v).value.up = prused+1;  		/* save as ptr */
		prused += obsize*len;  			/* bump prused by length in bytes */
		if( prused-EPR >=0 ) {eset(TMVLERR);return;}
		memset( kf, 0, prused-kf+1 );	/* zero it */
So to access this:
		void* where = (*v).value.up;
		int get_int(where);
		void put_int(where, int);
and similar put_int() and the other types (char, int*, char*). THEN a fetchToTop to get data into the stack, all properly typed.
But first we need to get data into pr. So far we initial to zero. We need to write the put_'s first and test them. Then eq. Then the fetch_'s. Then factor ~ 485 needs to be examined, adjusted to all the above, and tested.
x	get/put by type.
	eq
	impact on factor understood
	fixed
	possible enums: 
		type{ int,char,intStar,charStar }
		lvalue{ actual, lvalue }
		class{ ptr, datum }
	possible typdefs: all structs, enums, unions
char p() into decl doesn't allocate. char p(7) allocates seven bytes for the array. Then put_ptr clobbers them badly. So where to pointers go? Are they data? Can you use p=p+2 for example?
Tiny-c Owners Manual, p. 2-14 describes pointers. So
	char p(7) declares TWO datum. It declares p, and the array of 7 chars. JUST EXACTLY how does the 8080 code handle that? Time to study.
	char pointer(0) declares the pointer and allocates ONE byte. In fact p. 2-2, int values(10) allocates ELEVEN ints. ALWAYS allocate one more than toptoi returns. The zero in the decl MUST be there.
PUT Pointer not fix not tested yet, ditto get.

type codes getting confusing. Stack type vs old var size which implied the type, etc. 
On the stack 2 is int. pushk make that clear. Implication, 1 is char.

I think the whole thing is keep pointers (class>0) separated from actual data (class==0). Pointers kept in the var or the stack, never in the value store (pr). Kind of learned that messing with memcpy today. Int/char to/from var assignments illegal. And char is just a low precision int, so they can go back and forth, losing precision one way. Can still do pointer arithmetic. Diff between two, and add/sub of an int. The former is stored as an int. The latter as a pointer.

Lets get away from eq awhile, and try to define the type mystery.

type found in both tc.h structs (var, stackentry).
tc.c: all uses of type
	~58 1 char 2 int; 
	~75 if ptr set size=2 its a ptr WRONG (in eq)
	~131 pushst copy arg type into top
	~234 konst type: int 1, string 2, char 3, no match 0, err -1 
	~293 obsize computed from class,type INCORRECTLY
	~469 push details by type 1,2,3,-1 (from konst)
	~494 copy type from looked up var (addrval)
	~567 valloc arg
	~586 valloc code, used to compute obsize if(type=='C')
	~716 dumpStuff, 1 char, 2 int
	~723 dumpVar, dump whatever is there
	~753 dumpStack, "      "     "   "
konst is a variation. Dominate usage is char vs int. Pointer determined by class. An enum that encapsoates both may be nice,
with some macros to cover multiple cases. 

typdef enum type {char,int,charstar,intstar} Type;

Sunday, Sept 3
Segfault, test.c ~379, popst delivers a small number used as a pointer in print statement, %s format, "hello" is data. Could be bad pointer in stuff, could be no null but that woould be stopped by null at end of pr content. So bad pointer. Stack[0] has 11, [1] has pointer to 8. All popst does is --nxtstack and return pointer to the popped entry at nxtstack. 3 calls to factor, only 2 entries in stack, 3 factor()'s
Stack
 stack entry at 0: 0 41 1 (i)->17<- hex: ->11<-
 stack entry at 1: 1 41 2 (>)->8<-
testSetup("   17  \"hello\"  \'c\'  STRING-END");
MAYBE something wrong for type==char. It didn't get pushed. The string pointer has an 8. TRY stepping through konst() and see WHY the char case didn't get into the stack.
FIXED, enum issue.

Lots of bugs. Test 1 one good entry, 3 with chopped short name.
FIXED bug in test setup.
Test 23, trying to get eq to work. Never gets there. reln code is suspect, after the long if there is just } }. No explicet return. So it probably returns 0. 8080 code ~25ca if the last lit(<) fails, RZ ~2645. Is zero success? it matched the expr at 25ca. asgn~25c8 returns non-zero on success, reln 0, expr 0, term 0, factor eset's on failure, !0 without eset on success () case, jmp push|pushk on konst success, A is class there, return leaves class in A. SO FAILURE IN FACTOR IS FATAL, eset SYNTAX. term tests err after each factor call and returns 0 if set, hence a climb to the top with 0 in A. 
OK what does our C code do?
The if(lit)'s etc go from asgn to konst at the bottom. factor returns void, i.e. nothing but sets SYNTXERR if it fails to match. konst() returns type. term tests error and return 0 and the above stack all the way to asgn uses return 0 for no match. It mimics 8080 faithfully.
0 for no match, eset for Syntax error detected way down. Does it ever call asgn just to see if there is a match? And none esets, but the logic goes on?
GOTTA finish toptoi. 8080 ~352 online. 

psuedo code gradually transformed into C-ish ...
	int toptoi()   // resolve pointer and/or cast to int.
		struct stackentry top* = &stack[--nxtstack];
		if(lvalue == 'L') 
			if(type==Int )value.ui  = (int)(top.value.(int*)up);
			if(type==Char)value.ui  = (int)(top.value.(char*)up);
		else if(lvalue == 'A')
			if(type==Char)value.ui  = (int)(top.value.uc);
		return top.value.ui;


ADDED explicit returns up and down the stack. Test ran. Need to overhaul eq. An Int to Int assign: 

Toptoi now works for int data. Test 11. Needs to be tested for all other cases. Coded two ways, one liner which assumes the union puts char on top of the low order byte of an int or ptr, and 4 if selected cases for commented out for now if the union assumption is wrong. Work on that later. Lets get int tc to work.

Monday, Sept 4
Git notes 
From git config doc: https://stackoverflow.com/questions/12795790/how-to-colorize-git-status-output
	color.status.<slot>
	Use customized color for status colorization.
	<slot> is one of:
		header (the header text of the status message),
		added or updated (files which are added but not committed),
		changed (files which are changed but not added in the index),
		untracked (files which are not tracked by git),
		branch (the current branch), or
		nobranch (the color the no branch warning is shown in, defaulting to red).
git add <file>  --  Stages a file to be committed. NOT STICKY, i.e. 
	subsequent edits to the file require another git add.
git status  --  Shows files: staged modified untraced
git commit [--dry-run]
git reset   --  IMMEDIATELY AFTER a commit, undoes the commit
git checkout <file>  --  get older version
ref: https://git-scm.com/docs/git-commit
	This ref says git commit -a will do an add to all changed files before doing the commit. IT DOESN'T!!!
TECHNIQUE:
	git status
	git add <changed files not staged>
	git commit -m "<what was accompished message>"
	git status
The last status should be short, just the untracked files. Committing with assurance it took as intended seems to be these four manual steps.

Doing test output cleanup. Finding bugs.
	- Test 8, two ints have (c) in var dump.
	- Test 12, ~241, array has 11 (etc) WHAT IS the role of this??
	They are not tiny-c string and array. USE FAKE DATA, pr+99.
	- test 16, length of "hello" is 3
	- 17 not sure what the (>) points to. ints in 100-150 range?
	- 21 should show more than vartab. Doing an eq, show all state.
	- make diff shows way to much irrelevant stuff.
	- all need new Should get's
test 8, more class/type mixup. dumpStuff wants an 'I' or 'C' , not the enum. But it TAKES the enum arg and if'ing on it always fails.
Fixed one client, dumpVar.THE REAL PROBLEM is decl putting 'I' or 'C' into the valloc call. It needs to put the enum number. 

FIXED 	More hex: stackentry, poptop

Back to eq. Type table for assign...
int x; x=7;     <-- i = i      (Int row, Int column)
int x(); x=7    <-- i* = i   (IntStar row, Int column)
int x,y; x=*y;  <-- i = *i   (Int row, IntStar column)
int *x, *y; x=y;<-- i* = i*  (IntStar row and column)
ditto for char

		lvalue(whereToPut)	<--		datum				
						Int			Char 		IntStar CharStar
		Int 		*(i)w=(i)*w	 *(i)w=(c)*w	 *w=w	*w=W
		Char 		*(c)w=(i)*w	 *(c)w=(c)*w	 *w=w	*w=W
		IntStar 								  w=w	 w=w
		CharStar 								  w=w	 w=w
upper left block is class class 0 0. May permit class class 1 0.
Working now on class class 0 1 *w=w. 

w means where, address of respective side, lval left of =, val right.
destination = datum (resolved if necessary)
---
Step 1, get the datum. Into proper local type
	=w means  datum is val.stuff.up , no memcopy, already void*
	=(c|i)*w means datum in pr, memcpy to local datum of proper type

Step 2, put to destination
	w= means  val.stuff.up is destination, already void*
	(c|i)*w= means memcpy(w) local datum out to pr

toptoi coded two ways, one liner just casts union.value.up to int and returns it. The siX-liner distinguishes by top.lvalue and RESOLVES!
The pointer is certainly into pr. Actually both are wrong, but the one-liner serves for our simple (so far) tests. The six-liner probably should distinquish by type, not lvalue. But if its a pointer, what is the meaning of toptoi? Does it mean resolve, or return the ptr as the int result? DEFINITION IS SUE. psuedocode ~366 above suggests it is ptr to inc CAST, not resolve.

TOPTOI  CALL    POPST   ;class in A, lvalue in B,
        STA     TPCLASS ;  size in C, stuff in DE
        MOV     A,B
        CPI     'A'
        JZ      TT2
        XCHG            ;fetch data
        MOV     E,M
        INX     H
        MOV     D,M
TT2     DCR     C       ;if size 1 and class 0 return
        RNZ             ;  lo byte, with sign propgated
        LDA     TPCLASS ;  thru hi byte.
        ORA     A
        RNZ
        MOV     A,E
        RLC             ;propogate sign into D.
        SBB     A
        MOV     D,A
        RET
TPCLASS DB      0

8080 toptoi resolves the data if lvalue (B moved to A)>0. ;fetch data is the comment meaning resolve the pointer. XCHG swaps DE(stuff) and HL(garbage, so stuff is in HL) mov,inx,mov gets 2 memory bytes into DE, the rest is not germain to the issue. DE is the returned int.
It HAS to work that way for arrays! Close to the parser (factpr, probably) x(7) (parens, not brackets in tiny c) gets &x+14 (ints are 2 bytes) pushed onto the stack. Lvalue means pointer into pr where the real data is. And it is valid as an lvalue. 'A' means real data is right here. The CPI 'A';JZ jumps over the resolution code if it is an actual.

New toptoi needs to have resolution added. Probably can still resolve the one-liner. Stackentry needs to have union stuff to support actuals.

OOPS new eq thought. Confusing stackentry design from var design. Stack entry needs. Which can be JUST void*, not union stuff. Handy to have stack have RESOLVED DATA. Read the 8080 code. NOPE, union and unresolved it is, and lvalue is the distinguishing property.

ALL DATA OF ALL TYPES IS ALLOCATED EXCEPT PASSED IN VALUES.

scann for union stuff
763 dumpstuff, thats all. No service code written yet.

Tuesday, Sept 5
GOAL: finish eq. Next step is x=1 case and testing it. And removal of popSecond to get the pushed atts proper. NEEDS study. DONE.

Do classes 0 0 first. Study IS SUE: Why does C code examine val class, but 8080 code ignores it??? BECAUSE 8080 uses toptoi which dereferences. It delivers an 'A' even if top is an 'L'. Class is another issue. Class is needed to handle ptr vs int typing. The memcpy deal is NOT an 8080 issue.

REMEMBER: class class refers to on-the-stack classes, lvalue datum. NOT var.
(Easy reasoning mixup.)

IS SUE Finish eq, expand test 23 to all cases.
debugging test 24. decl didn't move cursor over the ) or ;
valloc responsible for the ), decl for the ;
status (9/5 10:30pm) segfault in put_int.

Wed, Sept 6
parsing x(1) by factor, does it push the right stuff???
~527 what is the type? It should be the type of the array, which is the lvalue type, which is type ~510. Should be ok.
Stack ends up empty, should be one entry, the pushed value. pushk is called. What happens? AHAH! st discards it. ALL IS KOOL.

ISSUE findEOS() and several other ways: find one way to test EOS.

DONE Next goal: MC(1,'x');
TOMORROW why nothing from test 26 ??? Good night!

Thur Sept 7
BECAUSE if code not written yet DONE
----------------
Fri Sept 15
Have been working on enter(). Needed three dependant functions, newfun, fundone(), and setarg(). And had to finish newvar.

Been struggling long time  with the rats nest of goto's in ASM code for newvar. Finished today refactoring, and tc.c version reflects that. Compiles. Ready to test. But had a put_int problem. Redid the where arg so it can come from other than the stack, e.g. a var. That too compiles. So testing should start with low case numbers that exercise the getter/putters.

Test 32 awaits use. First tests 22, 23, 24.

ISSUE: Can't we use the same management technique for each stack? nxtvar vs curfun, etc. nxt is the better choice, nxtWEver = wEver; eWEver = wEver+WELEN;
The overflow test is if(++nxtWEver > eWEver){eset(TMWE);return;}

22 ok, 23,24 fail to put data. 24 fails to allocate int x(3). ~359 if is wrong. We need to allocate this array. class==1 (correct). passed==0x0, pointer to stuff (correct), this is not a function call. 
        LDA     CLASS
        ORA     A       ;if class is 0, or not a passed
        JZ      NR2     ;  arg, then get value space.
        LHLD    PASSED
        MOV     A,L
        ORA     H
        JNZ     NR3
NR2     LHLD    PRUSED  ;get value space
nr2 allocates. above is the if. class==0 jumps to nr2 and allocates. class is 1 so passed is tested. JNZ fails, it is zero. So it falls into nr2. The if test should be BOTH ==0 as it was before. FIXED.
23 segs. parsing x=77. get_int, in eq ~113. On the stack val IS 77. lval is pr+18. Both correct. Shouldn't this be a put_int ??? . FIXED. 
And TEST 24 is happy, too.
make test segs. ~363, copyArgValue, test 17. newvar ~363. Dummy data was picked up as a pointer. Need to pass &union stuff... OR zeros. FIXED.
make test happy, make diff looks ok at a glance. NOPE. Test 17 "ref to pr[x]", the x's have changed dramaticly. 10 vs 101, 62 vs 102, etc. Test 17 repeats the 4 canon tests (1..4) but using calls to newvar instead of canon. It is really testing newvar. MAYBE those offsets are garbage anyway. The 'good' values are all in the 100's. The setups are all short, in the 10's. Other newvar data is garbage, (not a type, for example.) The test proves it creates entries, the data is not the issue. OK.
ALL diffs acceptable. make keep. Only 31 tests. 
test 32 is cleared for action!  It segs. newvar, copyArgValue ~388. test ~730. call to newvar with 'E'. First try at storing a 'where'. 
Both v and path == 'E' (0x45). newvar ~363. 
newvar prototype tc.c ~352:
	void newvar( struct var *v, 
		int class, Type type, int len, union stuff *passed ) {
newvar call, test.c ~730:
	newvar( &vartab[nxtvar++], 'E', 2, 1, cursor);
v,class ok. Not sure what len and passed are for class 'E'. Read the 8080 ASM.
There is no place in tc.c newvar we test for class=='E' and give special treatment. We do test for 0 often. Link is our guide, here. ~1786...
        MVI     A,'E'   ;allocate a variable with
        MVI     B,2     ;  class E, size 2, len 1,
        MVI     E,1     ;  passed value = cursor. (This
        MVI     D,0     ;  is a function entry.)
        LHLD    CURSOR
        CALL    NEWVAR
so 'E',2,1,cursor is OK args. Why was newarg copying a value? 
~359 shouldn't allocate space. passed is true, so it does the value thing WRONG. Best probably is explicitly if on type 'E'. But how did 8080 avoid this mess??? ANSWER: 
The copy would have been from passed into the var where pointer. And this has to be done. copyArg does that, ~388. 8080 code ok. What happened in our refactoring. It looks right for this case.
At ~387 class is 2, passed is 'E', WHAT HAPPENED? Args all switched around. Call and called match properly.
int copyArgValue(struct var *v, int class, Type type, union stuff *passed )
copyArgValue( *v, class, type, *passed);

AHAH, the call is to newvar from test.c ~730. 
newvar( &vartab[nxtvar++], 'E', 2, 1, cursor);
void newvar( struct var *v, 
		int class, Type type, int len, union stuff *passed ) {
cursor needs to be in the union. So at ~730 write...
	union stuff cur; 
	cur.up = cursor;
	newvar(...., &cur);
AND REMEMBER THAT when writing link. CHANGED. 
SEG fault again. ~388. at 387 passed is 'E', class is 2, type is huge hex, and v itself is 'E'. HUGE ARG MIXUP. We gotta start at test.c 730 and go step by step to tc.c ~387. b test.c:730, b newvar, b copyArgValue, the run 32, then look at all args received.
	union stuff cur; 
	cur.up = cursor;
	newvar( &vartab[nxtvar++], 'E', 2, 1, &cur);
---
	void newvar( struct var *v, 
		int class, Type type, int len, union stuff *passed ) {
---
	if( passed ) {
		copyArgValue( *v, class, type, *passed);
	}
---
	int copyArgValue(struct var *v, int class, Type type, union stuff *passed )


Sunday, 9/13
gdb, stepping through above. At ~358 all is OK. atts ok, *passed.up is pr+6. 
at copyArgValue...
	copyArgValue (v=0x45, class=2, type=6322246, passed=0x45) at tc.c:387
All screwed up. No proto in tc.h. Put one there and gcc now shows errors.
vAlloc ~685 vclass=0; But class is 'E'. This is the arg, not the fcn decl.
Might be ok depending on (*passed).up. NOPE. Alloc is called for argument 
~360, did alloc then RETURNED. error is 0. 
pr+6 is 0x607846   prused is <pr+51> == 0x607873
allocSpace never returned 0, so caused false eset, never tested so kept running copyArgValue never called. FIXED.
Runs to end, no seg, but MC(1,bar); prints nothing. 

Monday, Sept 18
Overcounting nargs. FIXED. But now seg'ing on test all...
	Program received signal SIGSEGV, Segmentation fault.
	0x00000000004016fd in copyArgValue (v=0x60a960 <vartab>, class=0, 
	    type=Int, passed=0xb) at tc.c:393
	warning: Source file is more recent than executable.
	393				put_int( (*v).value.ui, (*passed).ui );
	(gdb) bt
	#0  0x00000000004016fd in copyArgValue (v=0x60a960 <vartab>, 
	    class=0, type=Int, passed=0xb) at tc.c:393
	#1  0x00000000004015bb in newvar (v=0x60a960 <vartab>, class=0, 
	    type=Int, len=1, passed=0xb) at tc.c:363
	#2  0x00000000004033cd in doTest (testcase=1) at test.c:89
	#3  0x0000000000403211 in testing (argc=1, argv=0x7fffffffe0e8)
	    at test.c:56
	#4  0x0000000000400a47 in main (argc=1, argv=0x7fffffffe0e8)
	    at tc.c:15
Dummy data in early tests. FIXED
Not seg'ing but dumping " var:  0 None 0" lines 31 times, tests 17 up. Its dumpVar, unused line. Left it. Test 32 now in test all.

Link next, but a few more MC's would be nice.
-------------------

/*	get a char from keyboard
 */
	case 2:
		break;

/*	file open (r/w, name, fsize, unit)
 */
	case 3:
		break;

/*	 read block( where, unit)
 */
	case 4:
		break;

/*	write block ( first byte, last byte, unit). Block may
 *	be any size from 1 to 256.
 */
	case 5:
		break;

/*	close file ( unit )
 */
	case 6:
		break;

/*	move a block up or down. Args are first,last,K. If K
 *	negative, block is moved down |k| bytes, if positive
 *	then up K bytes.
 */
	case 7:
		break;

/*	count # instances of character CH in a block. Args are
 *	first,last,CH.
 */
	case 8:
		break;

/*	scan for nth occurance of CH in a block. Args are
 *	first,last,CH,cnt address. Return pointer to nth
 *	occurance,if it exists, otherwise to last. Also
 *	cnt is reduced by one for every CH found.
 */
	case 9:
		break;

/*	trap to moniter 4.0 for debugging.
 */
	case 10:
    	break;

/*	enters an application program, setting up a new
 *	globals variable level, redefining progend, links
 *	the program, executes if no error occured, upon
 *	completion captures a few facts (error, and either
 *	cursor or errat) and restores old globals level,
 *	progend, zeros err, pushes a zero as the value of
 *	this function, and resumes the calling program.
 */
	case 11:
		break;

/*	test if keyboard char ready, return copy if so,else 0.
 */
	case 12:
		break;

------KEEP ABOVE AWHILE-----------

Test 33 vs Test 8 should get same result. Somewhere 33 has extra nxtvar bump.
8 has 2 decl calls, 33 has one st() call to compound. Been getting these mystery "var:  0 None 0" lines in our test results. alternates between ~'s 689,366. 689 vAlloc as it calls newvar. 366 as it leaves newvar. Why does decl not do both??? It does. Difference is in dumps. 33 dumps 6 entries, 8 dumps 12.
How does 33 dump see ONLY 6 after installing 12? Because it stops after doing the int, it never does the char. 
Single stepping from end of decl-ent (~710) to see does it come back to decl.
Picked up error 9, SYNXERR, somewhere. Didn't eat the ) of b(). eset at factor ~620, looking at ). So who found the ( and skipped the )? vAlloc ~675, eat ) at 
683, but asgn's factor sets the error at 620. Factor should not error looking at ). vAlloc and factor faithfully mimic ASM on this issue. tiny-c evidently required a number within the parens. With that fix 33 now shows all 6 decls.
OK, now the mystery "var:  0 None 0" lines. Eliminate one of the two, 689, 366, ++nxtvar's. Which is logical. And which is ASM faithful. I think newvar (366) should take care of this, it is managing the table. 689 losses. FIXED.
BUT why does newvar have that arg at all; both vartab and nxtvar are global, and no other arg ever put there. Its a one liner in nxtvar. DONE. Bunch of code is cleaner. Tests print cleaner, too. KEEP.
Test 12 may have problems. Look it over tomorrow.  --  Good Night!

Sept 19 AM, FIXED.
ISSUE better names for globals.
git checkin DONE
Link is next. Written, test 34, too. Compiles. Tests GOOD.
git checkin DONE
Loader next 

Sept 20
AM: Decided to use out of the factory getchar() as sole keyboard reader, and do my own getLine(). Getchar does its own echo. Coded loader & its support brethren, including getLine. 
PM: Compiles. To test it must run standalone without test.c. Need alternative main(). Need cold start. 
Evening: Cold,warm,hot done. New main done, and old commented out.
IS SUE: where is link called? Should be just before st() ~872. FIXED
IS SUE: brake is a local in st but a global in ASM. Is local ok?
	NO. at ~762 brake=1;return and the parent recurse sees the old brake. It won't know to break out of the compound. Fix needed at ~708 and maybe 721. Subordinate ISSUE is be sure brake and leave are zeroed back appropriatly.
Compiles (8:53pm) but doesn't link. NEED logo, prbegin, prdone.

Thur, Sept 21
Goal, finish above. DONE.
Then move both mains into their own file and fix make to build two executables, 	tc, and test, each linked with their respective main. 
FORGOT TO GIT cold,etc. So I did it, but my main() refactoring went in, too. So that particular git commit is not buildable. Best to move forward and get the main refactoring and two executables working, THEN COMMIT THAT.
Makefile modified to produce two executables. Main refactoring compiles. Quick test of ./tc is OK. Goes into loader. Dot-x exits. More testing coming up, but first another commit so the most recent compiles and works even just a little bit. 
make dotest is the new make command to do ALL tests. OR ./test [test numbers]. Both work. 
TODO: 
	- MC's
	- pps
Most of the MC's not done (about10) are needed for pps, so they are 'a's in the ASM audit. Done are 1,13,14. Key ready on linux is messy, but I think catching a signal is pretty straightforward. I plan to catch ^C to stop a looping app and exit the app. The do forever loop in main loops back to warm which can load another app.
A faithful line oriented pps is the real goal. I wonder what a minimal character oriented one would look like?
ALSO its time to look into git-hub.
PPS: I'm up to line 8 of pps, and it is clear we need to redefine a bunch of MC's to support this. Enough MC anomolies observed I doubt I can be faithful to the numbers at that level. But I need to be faithful at pps library level. A good idea is to make the library its own file so others can import it. 
So that implies jointly doing the lib and the MC's. 25 fcn's in lib.
8 pm: read section 2.10 of owners manual, private MC's. Interesting. ISSUE: it describes MC calling in detail, specifically MCESET and USERMC stubs. Need to do those. ASM ~2198,2232.

Trouble getting traction on standard library. New thought is to let the std library dictate MC's. METHOD: From std lib doc (OM p. 2-21, sec. 2.9) write commented prototypes. Design MC's. Use existing def'n where possible, and 500's up for new. Code and test incrementally using test.c.
---
Friday, Sept 22
Two ideas: first make the 0 in a pointer declaration optional. Second implement printf. Even the variable data args is possible because a full MC implementation supports that.
Another: do a whole new lib that implements popular std C stuff. e.g. printf, but other stuff too. Call it newlib, or lib17, vs classical lib using ncurses???

Current approach to MC's doesn't scale well. Better might be each case calls an MCx(std args), and each MCx has its own locals to deal with the args.
Does C have a way to call a fcn whose name is a string??? NO. But a scalable way is working. No giant switch. Each MC is now written as a simple C function, any name, follow a protocol, and the model is in machineCall.c which is now separated from the tc.c file. Worthy check-in. Maybe more.
LOTS of MC calls in test and in testFiles are reversed args. FIXED, but test 33 broken. FIXED. Test 34, link, function items have HUGE pr offset, 1,627,904,576, for example. 35 looks good. make keep even with 34 bug. dumpVartab is good. ~376 does the deed. In link cursor needs to be put into stuff, because newvar expects a stuff, not a cursor. FIXED.
Other fun dump stuff: fvar seems nice, but lvar is Krazy.
Now print error at end of each test. Errors in tests 12,13. Others ok. Test 33,34 dump krazy var and fun table. Fun has 2 entries, 0 and 4. Var 'E' entries have crazy ref. I put the cursor into stuff and passed &stuff. Seems FIXED. But fun table is empty. error=3,2 tests 12,13 are intended. 

Saturday, Sept 23
BUG in test 34: fun table not dumping. FIXED
35 why the 'e' ??? OF COURSE, it was produced by MC(101,1). 101 aka 0x65 is 'e'. Redone a bit to be less confusing.
NEXT GOAL: all tc's prints. whole file read/write (new), stuff needed for an editor (scann, movebl, etc.)
printf can be done by very simple parsing the format arg, breaking it into strings terminated by %c,d,x,i,u,s and passing that format plus one datum to one of five fixed printf's. loop on that...
pm: 
Working on printf for tc. Stuff done: 
	generalized find() and mustFind().
	int charIn()
	firstFmt
--------------------------
Sunday, Sept 24
What is stuff.up? DumpStuff suggests it is a C pointer into pr. Does it ever point anywhere else? If not it could be an int index. Instead of pr+x, just x.
Need an audit of ALL uses. 

git diff to see where I am.  
Colors: 
	green seems to be new
	white both have (just a bit surrounding the green)
	red deleted
GOAL: Clean up the union stuff thing, probably just int stuff. Easy audit. I just did git commit. So erase the union from tc.h and make and see what happens.
Made fixes, not so bad. make dotest, make diff, not too bad. Stack entry prints are ONLY changes. And only prob is pr pointers which are now ints, 6326607 for example. Used to be (>)111, the pr offset. class 1's. dumpstackentry.
STUFF IS GONE! Long live the int! But not done. Those pointers should be indexes into pr. Both there and in var's. dumpStackEntry now nice.

Back to printf as tc lib function. Have working pFmt. Its sole arg now is the format string. MachineCall will have UNstacked the args, and called whatever(nargs, args); Need to write whatever() to call pFmt. Name? MpFmt? Why not.
Need thorough test of pFmt. 
6pm status: machine calls divided into three types, orig(0-99), new(100-199), user(200-up). Gonna make printf be #101. 
	int MprF(int nargs, int *args)   arg[0] is the format. 
	void pFmt(char *fmt) does its own toptoi. 
	testSetup("[ MC("hello printf MC",101) ]  ");st();
Should go to machinecall, newMC, Mprf which currently prints the format arg.
Args mixup is the issue. new test setup to be easier to follow args.
ISSUE: index base shift, BADDD!, machine call ~110. fix later.
Followed args carefully all way thru & into MpFmt, they travel properly.
Tommorow: change the 1st arg to a string, and debug why it segs.

Monday, Sept 25
Goin' after the seg. Caused by string as first arg after the format. This time didn't seg. machinecall stack dump looks good. toptoi bug fixed. Now args to MprF look good. REMEMBER pFmt needs to work from vector, not toptoi. WORKS!
Committed. 
I just implemented vPrintf. Ref:https://linux.die.net/man/3/printf
IS SUE: konst maps trailing quote to null for strings. Does konst look for both " or null for lvar?

NEXT GOAL: BACK to MC's. Back to library. All the g's and p's. As many orig functions as possible. IS SUE: rename the lib file library.tc. 

Tuesday, Sept 26
Library typed in except file i/o bodies. Need MC's 1,2,7,8,9,13,14,101 Propose to deprecate 3,4,5,6 and replace with 102,103. readFile,writeFile. Am I gonna do vscanf ???
PM: 
IS SUE MC7, movebl will PRINT its args to memmove (dest,src,n) but not do it quite yet.

Wednesday, Sept 27
Strategy: new test setup: testFile() optionally loads the library. 
Test 30 (MC1) fails. Ditto 31. 29, 26, 25. ALL MC1's. FIXED yesterday's half done fix and test. Back to the main track.
All lib fcns written except the file stuff. Test each. Write MC's as needed.
IS SUE endlibrary line at end is commented out.

putchar err's out in test 40. Cursor at space between char c, the arg decl. 
To follow I need to outline WHAT SHOULD HAPPEN then gdb find out what wrong.
	- cursor->putchar('h');   40 ~3, 
	- factor sees type 'E' ~585, calls enter
	- cursor->('h'), enter ~931 tosses the (,  ~939 parses the arg,
			~946 tosses ). 'h' on stack.
	- ~953 cursor=where, 965 parses char c, setarg(Char,<stackEntry>)
	- ~1016 valloc's char c with passed value.
	- ~983 st() does the body
Error 3 happens in asgn, ~939. Where is the cursor before this call? -->char c
It should be -->'h'
where==cursor on entering enter, cursor SHOULD be still on the call -->'h'
file loader was wrong, FIXED, but still fails. Freezes. 
   b link. Look at what is loaded...GOOD. loop is in link. Cursor at 190.
Loader left a null at pr+190. library follows. DID THIS cause link to FREEZE? yes, FIXED. Got into st(). Error 22, LBRCERR  -->), w(0), ...
	writefile ***cursor--> char n(0), b(0), e(
epr too small == 3236, cursor == 3244. FIXED. Now it freezes again, probably nulls at the end. epr too big by 2.
It would really help to have processErr() print out the line number, the line, and a carot under the cursor position. 
Anyway, seg in pFmt. fmt=0x1. cursor at ] at end of fcn putchar, ~7. And can we get a bt from a C library?
	https://www.gnu.org/software/libc/manual/html_node/Backtraces.html

Thur, Sept 28
The above fix (~811) was to subtract 3 instead of 1 from the epr calculation at test.c ~24. No rational, just change the number based on evidence. Better is to understand why -1 doesn't work, and -3 does. That leads to another thought. Loading the test statement first, followed by the library is backwards, but it too fixed a bug. But then the endlibrary statement at the very end of the load caused a problem. If it was at the top, then link would put the library vars in the first frame, and the best statement vars subsequent, as designed. So we have quite a cobbled framework, with cobbled fixes. BETTER is to load lib first, test statement second, then after linking set the cursor to the test statement. cursor=pr at test.c ~23 is the true problem. Do it more intelligently.
But is now a good time? Middle of a problem? Probably not. Get what we have stabilized. OK, so where are we? In pFmt with fmt=0x1, *fmt segs. More arg mixup. I wonder if our ptr-to-fcn thingy is making life too hard. Maybe switch is better, especially 3 switches for the three MC groups.

cursor-->] end of getchar, just after MC 1,c. OPPS. FIXED. MC c,1. Now getting "hello tc" then segs on mc 101. 
pFmt %s format bad datum. Its an 'h', not ptr to "hello ps"
At machineCall~187, mcno 101, nargs 2, *args->pr+760->"%s", *(args+1)==104=='h'
Should be & of where the h came from, -->"hello ps". Where was that dereferenced into 'h'? konst? Factor pushes fname onto stack, class 1, CharStar, 'A'. 
	enter ~942 calls asgn, should have on stack -->"hello ps"
	setarg "pts not impl yet", calls vAlloc
	vAlloc put name=b as class 1, type Char, len 1. len should be 8? type CharStar? b's value is 63...99. b value -> "hello ps". b is arg to MC, so setarg is probably the issue. at tc.c:967, just OUT of setarg. And it did the right thing, b with proper atts. But the pointer is a C ptr, not a tc one.
	b tc.c:940 (setarg loop). 
		first: cursor(pr+146)->"hello ps"
			where(pr+146)->" char b(0)[..MC..101", parsing ps call
		second: (after gdb continue): cursor(pr+771)->"%s", parsing MC call.
			stack is empty. Data from ps call in vartab, b, value is C ptr to "hello ps", (established an hour ago).
			where is 0, so machinecall coming up, ~949
	by now stack is popped, b is in vartab[24]. And in pFmt("%s",0), the ZERO is the problem. 
TRACE THE ABOVE AGAIN. 
	b tc.c:949 about to machine call. nargs(3) on stack: 101(top), b, fmt
	first: 	p stack[0].value-(int)pr == 772 -> "%s"
			p stack[1].value-(int)pr == 147 -> "hello ps"
			p stack[3].value == 101
	s -> ~177, nn..n past x=toptoi, p x == 104, 'h'. TOPTOI IS THE CULPRIT.
toptoi uses lval to decide to deref. Pointers are reduced to non-pointer single datum, an Int or Char. No CharStar. DESIGN TIME! And setArg has a comment ptr's not supported yet. 

Thoughts:
An lvalue can be assigned to. A pointer is an address. Lvalue is type 'L', pointer is class 1. 

		struct stackentry { 
			int class; int lvalue; Type type; 
			int value; 
		struct var { 
			char name[VLEN+1]; int class; Type type; int len; 
			int value;
So stack can have a CharStar,etc, 'L' or 'A'. Who decides these two atts? 

==>> GO LOOK AT EACH FCN AND LEARN REAL USE. And check pushk usage. And Type usage.

(Stack entry loses the name and the len.)
(Type has too many entries. Lose the None, its an error. )
-------------------------------------- code
factor
	SET: pushes constant onto stack(see konst), Int,Char,
			CharStar NO CASE FOR IntStar
		fcn call: USES atts of fcn name
		subscriped var: computes offset to element, 
						SET: pushes 'L' element to stack
		simple var: 	SET: pushes 'L' element to stack
eq() 
	USES: atts of val and lval from top 2 on stack
	SETS: lval value (because pointer), and pushes as 'A'
		pl("eq class class 1 0 not done yet");
		pl("eq class class 0 1 not done yet");
		pushK simple int/char value
setarg
	USES: stack atts, "CharStar & IntStar not implemented yet"
	PASSES: type to vAlloc
toptoi
	USES: stack popped atts, 
	note: resolves 'L' to 'A' for arithmetic. L needed for eq.

push's 
	USES: 	pushst: whatever's passed to it
			pushk: 0,'A', Int, datum passed to it
konst (computes atts, passes up to factor for actual setting)
	SETS:
		case Int: 		pushk( ATOI() );
		case CharStar:	pushst( 1, 'A', type, fname );
		case Char: 		pushst( 0, 'A', type, *fname );
		(no IntStar case)
--------
Now why? Both SETS and USES
	pointers: var has tc pointers (index into pr) to values EXCEPT 
toptoi would be ok for tc pointers. They are really pr subscripts. But type
	needs to be maintained, e.g. IntStar,CharStar. And C pointers should never get into var or stack.
C pointers should never get into any data structure. Only cursor, and derivatives of cursor used ONLY in C such as fname,lname. And array pointers if we go that way. Need to decide: all C pointers, or all int subscripts. Even epr, prused, etc.

Survey tc.h for style on structure arrays, nxt vs cur, limits, etc. Clarity is the object, not speed.
stack: 	int nxtstack STACKLEN
fun:	int *current *efun FUNLEN
var:	int nxtvar VTABLEN
pr:		*cursor, 
----
struct stackentry stack[STACKLEN];
int nxtstack;

struct funentry fun[FUNLEN];
struct funentry *curfun, *efun;

struct var vartab[VTABLEN];
int nxtvar;
----
CHANGES:
	- change efun to FUNLEN everywhere, or learn why not.
	- Keep *current because it will be used frequently to search locals
	- Change addrval to look up 3 frames
	- Add xStar types to setarg, toptoi
Design:
	- toptoi: if 'L' but type is xStar do not resolve. Keep xStar type.
	- setarg: keep xStar type onto stack.
ASM uses 1,2 for data type, and it is really 1 vs 2 byte. Actual role is determined by use, not declaration.
On the stack at machinecall
	class 	lvalue 	type 		value on stack		in args
0	1		65		charstar 	pr+772	%s			C ptr to %
1	1		76		char 		pr+147	hello ps	h

Two problems, 
	C ptr to % should be tc ptr to-->%s\0
	h should be tc ptr to-->hello ps\0
BOTH need pr subtracted before pushing. Second should be charstar.
BOTH pushed by factor using atts set by konst. 
Does toptoi do the right thing for charstar? evidently yes, by %s above.
Why did konst use charstar for one, char for the other, both being quote?
	BECAUSE "%s" was put there by ps's call to MC. library ~35.
	AND "hello ps" by passing b(0) from testFiles/40 ~8, call to ps,
		THEN setarg from stack to b

setarg ~1005 sees what? 'L' ??? assume so. pointers are lvalues. 
	vpassed='h'  ~1008

enter ~966: setarg(Char, &stack[arg]); <<== type BECOMES Char here!!! BUG
Needs to look betyond the xint/xchar for (0) and do xStar types.
setArg leans on vAlloc to do the parsing. It does lit xlpar but then ASSUMES it is an array decl. 

vAlloc parsing (therefor setarg) bumps type by 2 if it sees (. That should fix tc.c ~966 bug (notes ~937 above), and h vs hello bug (notes ~925 above). DONE
Now we need to fix ~924 above. konst? DONE

b machineCall:187 just before newMC(mcno-100, etc)
	mcno=101, pr+args[0]="%s", args[1]=101 which should be popped.
How did second arg get screwed up??? FIXED

Sat, Sept 30
toptoi 'L' now handles all types. New issue. Now that C pointers are converted to pr indexes, the C code that uses them must convert them back by adding pr. Did this to fmt in putchar. IS SUE can this be done generically before hitting the M code? To do that stack info needed. After toptoi can we look at the just popped stack for xChar and add pr? probably.

pFmt internally adding pr to convert tc ptr to C ptr needs to uncovert it on recursive call. This is getting ridiculous. Need ONE GATEWAY from tc to C and that is machinecall itself. Must look at type of datum.

Got to roll machineCall.c back. And roll forward good changes. HARD. 
Status:
	machineCall.c       Sept 24 version
	machineCall.c.bak   Sept 30 version
Diffing these gives 3.5 paages of differences, piped to less.
So far moved better comments, plus ~38 pft uses printf instead of pc.
Leaving pFmt at 9/24. Otherwise rolled back.
TRY IT: test 37 good, 38,40 segs.
DEBUGGING 38. MC101 w/ %d %s %d format. Probably the %s blows it. Some fix in .c.bak should not have been moved.
git diff machineCall.c: 
	pft: changed pc to printf
	origList: changed origList call args to nargs,args [was nargs-1,args+1]
		Changed it back. now segs on tc ptr to fmt.
Gonna try to fix pointers in the topto-to-args loop. two CharStar's in the stack. ~183 WORDS for test 38. Back to where we were sept 24 PLUS some changes. CHECKIN.
test 12 segs at test.c~872, in pft. Old test written with C ptrs on stack.
	The pft is called in test.c using errat data returned by tc which looks KRAZY.
test 16 segs. test.c~407 changed %s to %x. Runs to test 35 and seems to loop. Make test, make diff now run to test 38 with lots of broken stuff. Need total review. But no segs as of 8:39 pm.
REVIEW:
~1091 tc.c PrVal: if(class)printf("pr[%d] %x %x",val-(int)pr,val,pr);
	is the new dumpStuff. Assumes C pointers on the stack. IS SUE
TEST 8, char b(9) allocates 40 cells.
	12, stack entry prints 2 C hex addresses??? val and pr
	22, way more then 13 zero's same bug as test 8
	24, x(1)=77 written to wrong int array cell, x(2).
	34  error=2, but seems to work.
That's all. +pr pr+ gets into stacks, vars...
	12, that's all. All uses of +-pr are printf's based on cursor, prused, fname, errat, AND one "ref to pr[%d]"..value-pr. ALL var's, not stacks.
Thinking: all these are C ptrs, and should be. C on the C side, tc on that side. machinecall converts. NOPE
CONCLUSIONS: 
	- Its class, not type. No more xChar type. Use enums for class, Datum, Ptr, Fcn. Then at each scan point or dereference point set/reset class.
	- Get rid of the +-pr complexity. Use C pointers throughout. And put them in value space, not in var. In var they become globals. Many will be locals, and in val space they get properly collected.
	- Make lval an enum, too, Datum, Lval.
	- Do the enums later. 
x		- Do the if(class) instead of if(xStar) first. 
		- Then +-pr complexity. 
		- Then enums. 
		- Then lib first loaded.
pr complexity:
	Must allocate value space for full C pointers in vAlloc. 
x		newvar does this. 
x		typeToSize is ready.
x		most +-pr are in printf's. Only one +. Gonna keep some for readablility
x		Just a few in calcs.
x		no more CharStar except just for konst/factor.
		konst must return type and class ???
x		stackentry and var both have int value, need to go back to stuff
		toptoi ???
TESTING:
x	8, char(9) allocates 80 cells. int(9) also 80.
		commented out if(class) in typeToSize ~66
		not sure side effects.
x	remove two hex prints in dumpStackEntry
x	16 string can now be %s instead of the temp %x
x	22,24 same as 8
x	34 error 2, MAY HAVE SIDE EFFECTS
x	38 segs

3 bugs, one cosmetic, one improvement 
x	38 segs: pFmt. 

make dotest, make diff
x	8	- ~  76 int(10) allocates 40 bytes, not 80.  GOOD
x	13	- ~ 132 error,cursor = 2 D      OK, HARMLESS
x	17	- ~ 172 name in pr longer by 2
x	17	- ~ 187 Test 17 done error=8 TYPEERR  OK, poorly coded test

NEED Sun evening: 
tx	test 34, epr too small by 2. 
x	switch order of lib/test load
x	finish test 40

Monday morning, Oct 2, 2017

GIT FILES CURRENTLY BEING TRACKED:
	git ls-tree -r master --name-only
Ref: https://stackoverflow.com/questions/15606955/how-can-i-make-git-show-a-list-of-the-files-that-are-being-tracked

DATA test 40: lib loaded second, first char at pr+202, so testFiles/40 is that long (202). Null at end of lib load is at 3439, so lib is 3237 long.
And 40 freezes with cursor at 3438, the null. epr is 3439. 
REVERSED the load order, lib now first. 40 still freezes. cursor at 202, null. Fixed FileRead, returned len now excludes the safety null at end.
40 runs, multiple fixes, works fine. Up'd regression level to 40.

dir Tiny-C_new housekeeping
x	moved stuff into SupportStuff
x	note: old stuff is REALLY old
		COULD put .o's into object folder, .c's into source, and teach makefile to deal with it
x	22 file not too bad.
Agenda:
	Resume MC & wrapper testing
	typeless get/put for pointers. Where are they put??? 
		Don't know, but all is working.
	determine when to allocate space for a pointer
		Maybe pointer in var is ok. It isn't JUST globals, because
		var table pops, too. If value is a pointer it is an lval AND it is class=alen=1. There are no arrays of pointers.
	Full pps

Add pft to test 40
41: alpha, num, atoi, ceqn, 
42: move, movebl, countch, scann
43: file i/o

pps: enuf to type code, print all, and run it.
	up, down
	delete one line
	numbers on all above

Doing pft, MC 13, Mpft.   segs
	4 byte allocs made for pointers, b, from, to, but no copy args happened. TIME TO LEARN about pointers.

------
Tuesday, Oct 3
Whole day studying pointers. Started to allocate them in value space, but went back to allocating in var itself. One byte gets allocated anyway. Harmless. Back to union stuff in both stackEntrys and vars. LOTS of changes, but compiler helps.

Wednesday, Oct 4
Setarg needs pointer work. Goal is clean compile for now, and regression test, and then back to pointer work.
pushst may have an IS SUE. ~604 passes &foo as value, foo is a local. Then ~156 puts &foo on the stack. SO it points to a transient local!!! But stackentry has its own union. Need to copy somehow.
10 am, clean compiles. dotest segs.
	segs in test 32, but run alone its good. Garbage from 31 causing the seg in 32. cursor wildly huge. 
	~964 cursor=where, call to enter(char *where) from factor~589, came from addrval lookup of foo, where whould be pr+5 or 6. pr is 6330912, ox609a20. in vartab foo has up=0x7fff00609a26. LAST 4 BYTES CORRECT, but first 4 are the problem. Ptr entered vartab as an ui instead of up??? Foo is 'E', it was test ~763.
Test all runs to end, no segs. 

NEXT: review diff. Fix any problems showing up there. LOTS of diff output.
Test 6,8,17,21,22,23,24,31,33,34(var4,7),
6: bug in test code. 
8: HUGE allocs for int, EVEN for char arrays. 8 bytes per.
--------

Thur morning
typeToSize returns 8 for class 1. BUT class 1 always goes into var, not val. 
8: So only Char/Int matters. FIXED.
17: changed garbage types to 1's, 2's, nicer result, no more error
21: OK, but made it nicer
22,23,24: same as 8
31,33: OK
34: new vartable dump prints huge sections of code. var 1,2,3,10,11. link test. The where's do it. class 'E', aka 69. Should for that class print just the where, not *where.
ALL LOOK GOOD, now. 
make dotest segs. test 11, dumpStackEntry(0), 0,A,Int,7. Its on the stack as an actual, so should NOT be dereferenced by PrVal, which needs access to lval. CODE TIME. DONE
test_results now binary. ^@ for 0 Char 1. NOW prints "NULL". make diff is happy.
11,12,16 wild 0 A 2 pointers.
11: pushk(7) writes JUST the int portion of the union, does not clear the ptr portion. PrVal blindly prints the garbage pointer. It should print only the int value, 7. INNOCENT except for PrVal dump. Leave it for now.

COMMIT

Goal: resume MC's. 
Test 41 still segs. link, then st, dumps vartable with lib, then b 1 Char 1 pr[3414]. 
PrVal Char 1 val==? lval==0
Mpft dumps vartab, and printing from,to (args to pft)
	var 24: b 1 Char 1 pr[3414]-><-
barfs on 'from' arg...
$15 = {name = "b\000\000\000\000\000\000\000", class = 1, type = Char, 
  len = 1, value = {uc = 118 'v', ui = 6334326, up = 0x60a776 <pr+3414>}}
(gdb) p vartab[25]
$16 = {name = "from\000\000\000\000", class = 1, type = Char, len = 1, 
  value = {uc = 120 'x', ui = 6334328, up = 0x60a7760060a778}}
(gdb) p vartab[26]

b (which is OK) up=pr+3414
from has KRAZY pointer, garbage in high order bytes (0060a778). Lo order bytes are a copy of b's up. This is from gdb dump of vartab[26].
Could it be my memcpy? Why so many bytes? 
BACK UP. from=b+2, to=b+6. What is eq doing? b = "0123456789" ~5
	(gdb) n
~92	   (*lval).value.up = (*val).value.up;
	(gdb) p (*val).value.up
	$20 = (void *) 0x60a6f0 <pr+3280>   <-- val
	(gdb) p (*lval).value.up
	$21 = (void *) 0x60a776 <pr+3414>   <-- lval
	(gdb) p pr+3280
	$22 = 0x60a6f0 <pr+3280> "0123456789"   <-- val
	(gdb) p pr+3414
	$23 = 0x60a776 <pr+3414> ""
Looks ok so far. lval about to be 3280. CHECK. 
Now pushst val because we popped it twice at ~83. up 3280 on the stack. TWICE. Is that right? 
GOING ON... Next is computing from = b+2. 
Need to stack b, stack 2, execute toptoi twice and add and push the sum.
tc.c:516 , p stack...
{class = 1, lvalue = 76, type = Char, value = {uc = 118 'v', 
      ui = 6334326, up = 0x60a776 <pr+3414>}}, 
{class = 0, lvalue = 65, 
    type = Int, value = {uc = 2 '\002', ui = 2, up = 0x100000002}
top is 2. lvalue is pr+3414. class 1 Char at pr+3414. Why is lvalue 3414? 
Points to null. b should now be 3280. b is in vartab with 3414. What happened to b="123.." ??? Which we checked above. 

==>> The assignment was done within the stack. The vartab never saw it. this issue was noted before. 
Pointer arithmetic (put & get, both) needs access to vartab[?].value. Both names of elements, and index of entry are history by then. MAJOR IS SUE. Need to either communicate this data forward (UGH!) or allocate. We've mastered allocate. Pass forward is a total nightmare.

NEED: put/get pointers. These could range check, and add/sub pr so it is actually an int. But that detail is buried under the get/put, which always return C pointers. 

agenda:
	- get put ptrs SOME EXIST, NEED REVIEW
x	- find all places that do allocs, 
x		decl, setarg
x	- get/puts
x		eq, copyArgValue, setArg
x	- what they do
x		- decl			.parses, defers action to vAlloc
x		- setarg		.gets actual data passed to vAlloc
x		- eq			.data incl pntrs on stack, copys val->lval
x		- copyArgValue	.put_'s data to where.  line ~384 obsolete

Plan: 
	- review existing get/put ptrs. ~1224
	- visit each place above and decide what is needed there.
REVIEW
	get/put_ptr
		- these currently do a blind memcpy. No conversion tc/C ptrs.
		- not used anywhere
		- sizeof void*
		==>> RECODE to new spec, ~1138 above.
	decl
		- PARSER, uses vAlloc for action
		==>>
	vAlloc
		- important parser, sets up args for newvar
		- NEEDS detail review. Do the args to newvar suffice???
		==>>PARSING, uses newvar for action
	setarg
		- sets up args for vAlloc
		- get_int/char  <<== NO OTHER USE EXCEPT HERE
		- similar review
		==>> EVIDENTLY no test so far needed data from val space
	eq
		- parsing done, data on stack
		- uses put_xyz to do the assign
		==>>PARSING AND ACTION via put_
	copyArgValue
		- called by newvar to do the put_'s
		- both class and !class
		==>>ACTION
	newvar
		- fills out nxtvar
		- allocates space (uses allocSpace)
		- if passed, calls setArg
		- bumps lvar slot in current fun
		- bumps nxtvar
		==>> BOOKKEEPING, calls allocSpace,setArg for action

Most parsers defer to action routines newvar, setarg, copyArgValue. eq seems to be the exception. Assuming work is just at action points, only those 4 plus get/put_ptr need visiting.

Work Plan
	allocSpace
		arg to memset, 
		==>> CHANGE TO amount (cosmetic)
	newvar
		fill out nxtvar, allocSpace, 
		==>> PROBABLY NO CHANGE
	setarg
		from stack top fetches stuff as local. if 'L' get_'s data changing local into 'A' (but fails to change lval). Passes local to vAlloc where it trickles down to newvar which adds copyArgValue to its other bookkeeping. Evidently lval is never examined in vAlloc or copyAV. vAlloc parses the (, so setarg doesn't know the class of the arg decl yet. Its sole role seems to be to assure the value is an 'A'. Can a ptr arg be an 'L' ??? Probably. b=b+2 is an example.
		==>> ADD get_ptr to the L-to-A conversion.
	copyArgValue
		called ONLY if passed!=0, but has redundant test of that. Two cases: class, !class. 
		==>> REMOVE redundant tests (cosmetic). 
		CHANGE THE CLASS CASE to retrieve from var space (get_ptr).
	eq
		~87, whereSize never used. 
		~92 old ptr assign. CHANGE to get_/put_
		MOST of the action seems to be here. Most not implemented at all, yet (01, 10 class,class) Think these through. Write tc code that would put these cases on the stack. The 0 0 case looks suspect. Shouldn't the put_'s be to a where?
		==>> MORE STUDY.
eq cases, test 99
[	int b(9)
	/* b eq
	b(3)=7;
	/* at eq: p stack 		0 77 Int pr+151, 0 65 Int 7  CASE 0 0
	b(1)=b(3)
	/* at eq: p stack		0 76 Int 210	0 76 Int 218 
	b=b+2;
	/* at eq: p stack		1 L Int 206		0 A Int 0xBIGGIE (8 bytes) 
				should be case 1 1, but pushk made it 1 0.
	int a(0)
	a=b;
	/* at eq: p stack		this would be a 1 1
	Do we support int x; x=b; ? OR b=7 ? The latter fails our propsed range check on put_ptr. The former doesn't but can be dangerous.
]

CLARIFY: class 1 means "the data is a pointer"
	Lvalue 'L' means "where points to the data"
	class 1 'L' means "where points to the data which is a pointer"

IS SUE needed ; after b(3)=7 because asgn tried to do 7/*.

Doing b=b+2 got error 14. toptoi LVALERR. 3rd eq ok. 4th bombs. After 3rd cursor-> MESS of comments, then: int a(0)  a=b. That means just parsed is b=b+2. Stack should have b (lvalue) b+2 (val). 
	nxtstacck = 2
	stack:  { 1 L Int pr+312 }  { 0 A Int 0x609b5800609b5a } should be pr+314. Only + in the program. b on tc.c:515.
b tc.c:516 (before the addition)...
	nxtstack=3, stack has: b: 1 L Int 312, another b: 1 L Int 312, 0 A Int 2. All is good. BUT pr+312..315 is 4 nulls FOLLOWED BY GARBAGE. 
After addition: (pushk toptoi+toptoi) stack is 
	nxtstack=2, same b: 1 'L' 312
	b+2 is: 0 A Int val whose ui increased by 2, whose up low bytes increased by 2 BUT high bytes huge garbage. Pushk did its job.
==>> pointer put_/get_'s are flawed. alloc nulls only 4 bytes.

This problem will be fixed by the new simpler design. typless storage holds ONLY char, int, not void*. get/put_ptr adds, subtracts pr. BUT toptoi may be a problem. And ditto pushk. toptoStuff???, pushStuff??

Saturday, Oct 7, midnight.
Took break the last 36 hours. OK, Lots of study. Time to code.
x	- put_/get_ptr's
x	- adjust vAlloc to alloc only 4 bytes (int) to store class 1's
	- state changes above, ~1160, etc.
x		- setarg
x		- copyArgValue
x		- eq
state changes TOMORROW.
--------------------

Sunday, Oct 8
First try: eq, setarg, copyArgValue
Doing test 99 one = at a time.
	JUST b(3)=7;  ==>> error 9
		vartab b 1 Int 10 pr+256
		stack: 
			0: 0 65 Int ui 7 up 0x7000000007
			1: 0 65 Int ui 7 up 0x1000000007
		pr: 0x609a20  epr 245, prused 295.
		value: 7 in slot 262
		b eq, stack: 
			0: 0 76 Int pr+268
			1: 0 65 Int 7
				CASE: 0 L <- 0 A
				eq did the assign
				parse error, factor looking at ]. WHY???
	UNCOVERED b(1)=b(3);
 		<pr+164>:	0x00000000	0x00609ad0	0x00000000	0x00000007
 								b(1)					b(3)
		. above after assign done. 
	b eq, stack: 
			0: 0 76 Int pr+268
			1: 0 65 Int 7
-----------------------	
Monday, Oct 9
After the assign b(1)==609ad0==pr[176], the value pointer exactly.
In 0 0 case, stack: (nxtstack=0 due to two pops at ~84)
			0: 0 76 Int pr+268
			1: 0 76 Int pr+176
This seems so different from last nights "after assign done". The 2nd is b(3), correct. Why pr+268 ??? prused is 203. 40 bytes for int(9) GOOD. This is the 2nd =, the first b(3)=7 pushed 
Walk thru b(3)=123  (0x7b, a bit more noticable in hex dump)
		stack before 
			0: 0 76 Int pr+268  <-- lvalue, WRONG offset
			1: 0 76 Int pr+176  <-- datum, WRONG lval, wrong value
268? b is 166. b(3) is +=12 is 178. 123 should have been parsed by konst, and put onto stack[1]. It is NOT an lvalue. 
Cover line 8. Focus on line 5 for awhile.
---
line 5, nxtstack 2, var b 168, 		stack before 
			0: 0 76 Int pr+180  <-- lvalue
			1: 0 65 Int 123  <-- datum
		ALL GOOD, step througn eq...
			10 n's  -> line ~106, 0 0 
one fix, ~109 should be up, ditto ~114. x /d pr+180  has  123 GOOD.
Continuing now will hit our other parse bug. YUP, error 9.
uncover ~8. apply ~109/14 fixes. make. DONE
---
repeat above at line 5, var b 166, lvalue at 178, otherwise SAME.
walk thru this assign, and examine stack before leaving eq.
	stack after pushk(iDatum)...
			0: 0 65 Int 123 GOOD
			1: 0 65 Int 123  <-- left over from pop
c next eq  b(1)=b(3);   nxtstack 2, stack 
			0: 0 76 Int 170
			1: 0 76 Int 178
	These should be b(1),b(3). b=166, so GOOD. pr+181 == 123 (7b) GOOD
	Case 0 0 again, but two 'L's. nexting...
	iDatum is pr+178. BAD. Did not deref the L, ~108. It points to 123.
FIXED. b looks like this...
			0x609ac6 <pr+166>:	0	123	0	123
			0x609ad6 <pr+182>:	0	0	0	0
			0x609ae6 <pr+198>:	0	0
YAHOO! Now lets fix that parse flaw...
	~725 for loop calls st() repeadedly until ] breaks out, or
		error. st() is at ~732, last in loop.
	One c causes error 9. never reached 732. line 8 of test 99 last reached. 6 c's at st() cursor at line 9. cursor -> ']'. asgn() should fail, but not error. Instead it uses error to decide on failure. That is too harsh. factor ~625 class eset. All the parse stack returns int succ/fail EXCEPT factor, which just sets an error. IS THAT ASM?
FIXED, but other stuff is broken. Uncovered rem() ~726.
TODO: 
x	- add prints to 99, two pn's. MC101 works.
x	- move test 99 to 41. 
	- dotest, diff, see what else is broken.
	- COMMIT
got a good make diff...
	22 has more 0's (used to be 13), now >19
	25 has negative pr index's, MC 1
	several have stack dumps but their prints can be found among them.
		25, 26,29, 30, 31, 
		32 has error 21, 
	MOST are ok. 
--------------

Tuesday, Oct 10
Goal: What accomplished?
Another: clean diff, then make keep.

Accomplished (when done):
	Test 42 (not 99 anymore) nails down eq treatments 4 cases, 2 being violations. (cannot assign int to ptr or vice versa). So valid cases are  00, 11. Clarified respective role of class 1 and lvalue. ~1226 above.
22: why >19, should be 13 0's?
	char p(7);  need TWO valloc's p, and the array. p is an int, the array adds 8 more, 12 total to the previous 5: should be 17 0's.
But that requires proper interpretation of var where, it points to one of the two allocs, and add/sub 4 to get the other. ptr first. array second. 
	where points to the array. 
	where-4 points to the ptr. 
	where+(obsize*index) points to the array element. 
1st & last SHOULD already work. The pointer offset (-4) is new.
What is probably happening in valloc or newvar is char array space allocated with obsize 4, ptr obsize, (stored as int). 
valloc:
	f/lname defined (symname)
	( ? then 
		newvar(1,type,1,0);--nxtvar;    <<== add this
		vclass 1
		alen=subscript (or 1 if vpassed), 
	else 
		vclass 0
		alen 1
	newvar(vclass,type,alen,vpassed);   <<== existing
The result is ONE var entry for two variables in the ( case. To get to the pointer back up by 4. AND YOU ALWAYS HAVE TO DO THAT because the value of b in var may be no longer valid! AND you gotta set the pointer to the var where value.
WHEW! Is it worth it? What was the argument to allocate pointers in value space instead of its var???  WAY BACK. Study from ~953 above forward.
	~983 documents the decision. Wrong reasoning about global, vars DO get popped.
	~990 adds to argument.
	The clincher was eq not having access to vartab. Or name. 
		int a(),b();
		a=b;
		b=b+2, how did ASM handle these?
TRYING TO DO TOO MUCH. Owners Manual, p 2-15, "a pointer expression is a pointer +/- an int." So both above assigns are ok. But b-a is not. AND EQ in ASM works strictly with the stack. That implies an lvalue can point into a var. a=b will have two such lvalues. b=b+2 will have one (b), plus an actual (b+2). CHECK THE ASM CODE for these implications.

ASM, ~1219 FA7: look up symbol. addrval returns all data in registers. FA10 for symbol without (. Could be datum or pointer, class determines.
FWHERE is in DE, pushst called ~1296. 
		FA10    LDA     OBSIZE  ;push class, 'L', obsize,
		        MOV     C,A     ;  stuff=where.
where (FWHERE in the code) is taken from the var. If its class 1 it is where the data is. 
So b=b+2, the b is on the stack twice as 1,L,type,where. 
	Then the 2 goes on as                0,A,Int ,2
	Its all up to eq. But eq does not know where where is stored, only its value. UNLESS addrval returns where as a pointer into var, not the value stored in the var. That would be a valid 'L'. 
;ADDRVAL looks up a symbol pointed to by FNAME,LNAME.
;  Returns address in HL, class in A, size in B, and
What address??? ~944, match: 
		        ORA     A       ;if class > 0 & class < 'E'
		        JZ      AD9     ;  then return address of fval
		        CPI     'E'     ;  part of VARB, which is alrdy
		        RNZ             ;  in HL.
		AD9     PUSH    D       ;otherwise return contents of
		        MOV     E,M     ;  fval part of VARB.
For class 1 it is the address into var where where is stored. 
DONE! It is MUCH simpler than I thought. 

Change plan
x	remove get/put_ptr
x	git diff tc.c shows typeToSize, eq changes ONLY. Review these.
	visit each use of above (get/put) and put it back the way it was
x		eq done. But kept the lval dereference. 
x		typeToSize now ignores class. Does only Char, Int, else error
x		copyArgValue
		setarg
All tests run, no segs. Errors, though. 
FIXED 37 Pfmt, got 77, didn't get the string. pFmt is a C not a tc call.
41 	b is var[24], then from, then to. 
	b is pr[3414]. from and to are both garbage. BUT intelligent garbage.
	b    = 0x60a776
	from = 0x60a7760060a778
	to   = 0x60a7760060a77c 
	to = from+5    from=b left-shifted-4-bytes + b+2
Dump of 'from'
0x60f560 <vartab+800>: 0x66 0x72 0x6f 0x6d 0x00 0x00 0x00 0x00
0x60f568 <vartab+808>: 0x00 0x00 0x00 0x00 0x01 0x00 0x00 0x00
0x60f570 <vartab+816>: 0x01 0x00 0x00 0x00 0x01 0x00 0x00 0x00
0x60f578 <vartab+824>: 0x78 0xa7 0x60 0x00 0x76 0xa7 0x60 0x00


name 0x66 0x72 0x6f 0x6d 0x00 0x00 0x00 0x00 0x00 9 bytes  "from"
 | packing 0x00 0x00 0x00 
 | type 0x01 0x00 0x00 0x00
 | len  0x01 0x00 0x00 0x00
 | value  0x78 0xa7 0x60 0x00 0x76 0xa7 0x60 0x00
Low order bytes first. from at ~1402 above completely flops the order of display for readability. 
Now lets do it for b.
 | value  0x76 0xa7 0x60 0x00 0x00 0x00 0x00 0x00
How did the hi order bytes get into from ??? Hypothesis, unions right pack everything. AND pointer stored as ui becomes wild hi order. And ptr+2 somehow becomes an Int.

New thought: Should var use union stuff value, or char* value? Does it ever use ui or uc? grep turns up nothing. 
----------------

Wednesday, Oct 11

Goal is to fix the mangled pointer in the var table.
-m32 needs lib fixes to work. Back to 64 bit. 
Review of make diff: all good except 41,42.
	Test 42 works but gives error=9
	41 fails to parse second arg, factor looking at comma. 
		cursor->",b+6\n]\n"
42 doesn't have all code uncovered.
41: 
	Goes through enter ok parsing args, then decls. Need to check the data it is producing. Problem probably in setarg, or MC.
	Run again with JUST mc break. Two mangled pointers on stack.
	ui = 0x60a778, up=0x60a77660a778. ui is in the low order bits. This is the first arg, from. to is similarly mangled. 3rd is 13, the MC number. Problem is in setarg. 
Thought: what if we change from union to struct? Better thought: brkpt setarg and look at the pointer before and after the assign. 
AT setarg 1st hit the pointer is already mangled.
	watch'd ptr, mangled at 
		tc.c:159 stuffCopy, 168 pushst, 176 pushk, 523 expr.
stuffCopy doing a memcopy of one stuff into another. PUSHK USES UI.
~523 is pushing b+2.   pushk(toptoi()+toptoi());
stackentry knows class. Can assure pushPtr. Examine toptoi and pushk to see if class is properly passed on. TOPTOI class 1 returns ptr cast to int. pushk makes it class 0 'A'. 

Put the burden on expr to push a pointer if either side is class 1, but only for +-, not the other ops. New fcn pushPtr. NOW 41 completes with error 14, lvalerr. 
	nxtstack = -1. 
	cursor --> ",b+6" so it is adding b+2.
Breakpoint 2, expr () at tc.c:534
	pre-addition:
	(gdb) p nxtstack   2
	(gdb) p stack[0]   {class = 1, lvalue = 76, type = Char, 
						value = {.., up = 0x60a776 <pr+3414>}
	(gdb) p stack[1]	{class = 0, lvalue = 65, type = Int, 
						value = {.., ui = 2}
----------------

Thur, Oct 12
Do the above watching the addition, AND the eq. Put a watch on error. Lvalerr will be in eq.

41:
	pr+3280 == 0x60a6f0 -> "0123456789"
	pft args should be 3282 == 0x60a6f2, 3286 == 0x60a6f6
	pushPtr datum is 6334328 == 0x60a778 which points to nulls.
	Stack has 0x60a776 + 2, vartab b is 60a776 == pr+3414. 
		==>> b="01.."   assignment done WRONG.
	Back up to eq. stack has 
		(0): 1, L, Char, pr+3414
		(1): 1, A, Char, pr+3280 -> "012..."
	After assign vartab should have pr+3280. 
	The 3280 needs to go into var[24], which before assign HAS 3414. 
		(gdb) p &(vartab[24].value.up) == 0x60f558 <vartab+792>
	The lvalue ((0): above) should be 0x60f558 <vartab+792>
	Back up more, to parsing the b. That is in factor after symname.
	b ~604, 1st hit is b="012..", cursor->leading quote. 
WHAT SHOULD HAPPEN: b gets the value pr+3276->"012..", BUT ~631 pushes the value vartab+792 because b is class 1. But that push doesn't happen AT ALL because no lit(xlpar). And if it did, its pushing 'L' &foo for all classes, not just class 1. PROBABLY WRONG, but ok for this case, so keep chasing. 
NOPE. WHERE does the &foo get dropped or ignored??? And foo is a local, so the pointer becomes invalid almost immediately. 8 uses of foo in factor! How long has foo been there? git diff tc.c|grep foo returns empty. So way before Oct 5.
THESE NOTES ~1374 IS WHEN I discovered &fval is returned by addrval for class 1, instead of where, so it could be used as an Lvalue. ~952 of tc.asm.That was Oct 10, 2 days ago. So introducing foo was to solve some earlier problem. HOW TO DIFF back 2 or 5 commits ago with today, or with its next neighbor.
												 oct 2..oct 5
tom@East ~/UbuTom/Projects/Tiny-C_new $ git diff e8828..fae01 tc.c|grep foo
+	union stuff foo;
+			foo.uc = *fname;
+			pushst( 0, 'A', type, &foo );
+			foo.up = fname;
+			pushst( 1, 'A', Char, &foo );
+						foo.up = where;
+						pushst( class, 'L', type, &foo);
+					foo.up = where;
+			  		pushst( class, 'L', type, &foo);
---------------
Fri, Oct 13
Most of the foo stuff is probably ok. Regression proves that. Only need to debug tests 41,42. And foo has nothing to do with that. Foo solved the mangled pointer problem. addr needs to return a POINTER to var's where. Does it? ~1461 above. 
The &stuff as arg to push is ok, because it is COPIED into var. Thus its local-ness is not an issue. 
At ~604 *v is the foundVar. In factor. ~629 is no ( case, called simple. ~630 is the magic. No address-of logic. Foo will get COPIED by pushst. For class 1 it must be 'L', &foundVar.value.up. That goes in the STACK copy. 
&((*v).value.up), will that be what we want. It is v+offsetToValue.up.

gdb at ~602. WHAT SHOULD HAPPEN: b gets the value pr+3276->"012..", BUT ~631 pushes the value vartab+792 because b is class 1. [3276 now 3280.]
WHAT IS HAPPENING: at ~631 foo is pr+3414 taken right out of *v. Points to null. DOES NOT point to "012..". Did the assign at test 41:~6 go wrong?
TODO: check the assign at ~6.
DOING: chase the b+2 works ok. 
	ALSO chase the &((*v).value.up) == vartab+792 -> <pr+3414>. 
FIXED ALSO: ~631.
segs in Mpft. Probably trying to deref a null. We know b has wrong where value, Should be 3280 (+/- drift). 
	char b(0) will point to the null byte allocated. 
	b="012.." should change that to 3280. 
		b eq. 
			Look at vartab[24] aka vartab+792.
				is b 1 Char 1 pr+3414 -> NULL
			look at stack. 
				is 0: 1 'L' Char vartab[24]==vartab+792  <== offset? (24)
				   1: 1 'A' Char pr+3280 -> "012.." <==GOOD
			walk thru eq. 
				.
		Factor should pushst b with pointer to b's where cell. 
		eq should change that cell to point to "012..".
		at ~93	if( (*val).lvalue=='L' )  val is 'A', so this deref not done
		at ~96  (*lval).value.up = pDatum;
			This is the actual assign.
				p (*lval).value.up   (void*)0x60f558 <vartab+792>
				pDatum is pr+3280
		p vartab[24]:   b 1 Char 1 pr+3414, Where did pDatum GO ???
		Before and after assign (printf's)
			lval's up into vartab 792, pDatum in pr 3280
			lval's up into pr 3280, pDatum in pr 3280
p vartab[24]
$1 = {name = "b\000\000\000\000\000\000\000", class = 1, 
  type = Char, len = 1, value = {uc = 118 'v', ui = 6334326, 
    up = 0x60a776 <pr+3414>}}
STILL 3414 in vartab.   ^------ should be 3280.


Did the assign go into the stack, not into the var.value.up. NO IT WENT INTO THE LOCAL 	struct structentry lval.

The lefthand side of the C assign (~99) is wrong.

		(*lval).value.up = pDatum;  /* assumes up points into var */
	SHOULD BE
		void* where = (*lval).value.up;
		*where = pDatum;
FIXED
NEXT: test 41 sets in machine call, the two pointers on the stack are into vartab. from and to. And the two decls from and to are in vartab[25]/[26]. pps/library.tc, ~17, pft written in tc uses MC 13 which calls pft written in C. Should be straight forward ESPECIALLY because a comment in setarg says "cant do pointers yet."
setarg needs to do exactly what eq does for class 1. ~1034, is (*arg).value proper, i.e. ptr to pr+3280 + 2|6 for from|to. 
OK not exactly. Setting a value into a new ptr var is not the same as making the var be an lvalue for eq. 
setarg ~1044. 
----------
Sunday, Oct 15

At machinecall: 
	stack: 
		0:	1 'L' char vartab+824   (from)
		1:	1 'L' char vartab+856   (to)
		2:	0 'A' int 13  (pft MC)
	vartab
		25: from 1 char 1 vartab+794
		26: to   1 char 1 vartab+798  (4 bytes apart.)
	792 is vartab.value. 
SHOULD BE:
	vartab
		from 	1 char 1 pr+something (3xxx)
		to		ditto five bytes later
	stack
		0:	1 'A' char pr+3282   (from)
		1:	1 'A' char pr+3286   (to)
stack issues: 
		term ptr+int: 
			ptr's 'L' value must be derefed
			after addition pushed as 'A'
		setarg: may be fixed by above. 
At tc.c:534 (term infix +)
	stack:
		0: 1 L char vartab+792
		1: 0 A Int 2
	==>> Have to deref the L But NOT the class 1. L ptr is to union stuff in var[24], which ->'s to pr+3280. GOOD. toptoi DOES a deref of an L, And pushPtr preserves the class 1. Good. Is it the toptoI? Step through to the push, see what it does.
b tc.c:534: Then in pushPtr, d.up = vartab+794, WRONG. The problem must be the use of toptoi. It coughs up a value NOT dereffed.
----------------
Monday, Oct 16

Thought, ~191, Int? Maybe type of b??? var b, not the b of a+b. LATER

AT a=toptoi, step into toptoi.
	stack top: 1 L Char vartab+792 AHAH! class 1 skips the L deref!
recoded:
		if( (*top).class==1 ) {
		if((*top).lvalue == 'L') {
			ptr=(char*)((*top).value.up);
			datum=*ptr;
		}
this is BAD CODE: At toptoi ~140, ptr=vartab+792, datum=-16. ptr is to union, not char. FIXED. Still seg's. 
LOOKING for 0x60a6f0->"012.." to be the left term. 2 IS the right term.
	0x60a6f0==6334192
	the stack has 1 'L' 0x60f558 == 6354264. 
	datum is  0x60a6f0 == 6334192   SO 'L' deref happened.  GOOD so far.
	at ~545 before pushPtr(a+b), a=6334192==0x60a6f0, b=2  GOOD
	after the pushPtr, nxtstack=1, stack= 1  'A'  Int  pr+3282. GOOD
	p (char*)stack[0].value.up
	$37 = 0x60a6f2 <pr+3282> "23456789"
assume *(b+6) will be "6789", we have two valid args, from and to.
At machine call both args point into vartab. 
	824 and 856 (delta 31)  aka  0x60f578 and ditto+delta
==>> changed somehow during pft/MC parsing. That would be setarg.

b setarg   This would be from, looking for Pr+3282...
	p *arg    (struct stackentry *):   1  A  Int  pr+3282
	an Actual, so passed directly to vAlloc.
vAlloc does the parsing passing vpassed to newvar.
newvar ~374: 
	passed is a wierd pointer, &somethng on the C stack. 
	Data ok. 1 Char 1 &passed
	passed is ignored until ~381, then into copyArgValue
copyArgValue
	ONE line of code ~406. 
			(*v).value.up = (*passed).up;
	after: from 1 Char 1 pr+3282
	p *v
		$48 = {name = "from\000\000\000\000", class = 1, type = Char,  len = 1, value = {uc = -14 '\362', ui = 6334194, up = 0x60a6f2 <pr+3282>}}
	LOOKS GOOD. 
Out of setarg, enter ~1010.
	14 n's later second arg done, at ~1027, execute the body of pft. The cursor shows "[\n/tMC from,to,13\n]..." And from,to should be on the stack as pr+3282/6 respectively. Both there, good, 1 A Int, pr+3282/6.
	==>> The Int may be an issue.
At machinecall. The stack has vartab stuff. Damage is before machinecall
	printf ~109: 3282 3286 relative to pr.
GCC lib or link flaw: putchar cannot be used. changed to printf("%c",xx); in a for loop! For the record...
		"Program received signal SIGSEGV, Segmentation fault.
		fputc (c=50, fp=0x2) at fputc.c:37
		37	fputc.c: No such file or directory."
		(gdb) bt
		#0  fputc (c=50, fp=0x2) at fputc.c:37
My code calls putchar, putchar uses fputc.c. Code compiles, links, runs ok until putchar is called. Seg's there.
ANYWAY    FIXED   Test 41 success.

Still segs. Still gets bad from/to at MC level. 
NEW THOUGHT. addrval looks up from whole vartab top to bottom. It hits pft from,to and uses that instead of MC from, to. SAME NAME. Change the name for a test of this thought. Then fix addrval so it searches properly locals, globals, libs.
------------

Tue, Oct 17
Doesn't seg this morning. 41 is good. Moving to 42.
42: best run in gdb, examining state changes (cursor, stack, vartab[0|1]) in detail.
	error 9 set in factor ~649, cursor -> "*\tb=b+2" line 11 of test 42. Why is factor looking at *. It must have eaten the / of /* and is trying for another expr denominator. AND b=b+2 is commented out. Its the MC line.
b ~610, at MC's enter call. n past that and find where \n is eaten, leaving factor confused.
	lit eats \n's. I'm sure it has to. What should prevent that if factor believes it must keep going? 
	ASM ~1640..16 tests for no args several ways using cpi, NOT advancing the cursor, leaving it at ] ; <cr> /   But if args, uses , to keep going. lits the optional )    
	then tests for MC, calls it & returns if so.
term ~556 eats the \n's. This watchpoint proves... term calls lit
		Hardware watchpoint 1: cursor
		Old value =  "\n\n/*\tb=b+2;\n\t/*** 13 ***
		New value =  "\n/*\tb=b+2;\n\t/*** 13 ***
		lit (s=0x4061b3 "*") at tc.c:219
		219		while( *cursor == ' ' 
		$120 =  "\n/*\tb=b+2;\n\t/*** 13 ***
		(gdb) bt
		#0  lit (s=0x4061b3 "*") at tc.c:219
		#1  0x0000000000401fd2 in term () at tc.c:556

		(gdb) c
		Hardware watchpoint 1: cursor
		Old value =  "\n/*\tb=b+2;\n\t/*** 13 ***
		New value =  "/*\tb=b+2;\n\t/*** 13 ***
		lit (s=0x4061b3 "*") at tc.c:219
		219		while( *cursor == ' ' 
		$121 =  "/*\tb=b+2;\n\t/*** 13 ***
		(gdb) bt
		#0  lit (s=0x4061b3 "*") at tc.c:219
		#1  0x0000000000401fd2 in term () at tc.c:556

I believe this is a bug in the 8080 code. OM chapter 4, sample programs never use comments alone on a line eacept after ] . I fixed 42 with a ; before the comment line. Leave it for now.

41 now misbehaving. error 9. Runs properly though. Proper results. cursor at comma between args, line 6. factor 649. 
Thought: It can be same as 42 issue. Somehow it should be OK for asgn to learn it is done, no more relns, exprs, terms, factors, JUST a character not ever in an asgn anywhere, AND that is ok. Difference between insisting vs allowing more. And don't eat the character (e.g. comma, or newline) that ends it.  The only parse change is rem() as 1st line of for(;;) for compound statement, lit(xlb), st() ~749. It's redundant. The loop calls st and st does a rem call. This is there to do a cleanup call before leaving the loop. Ditto ~752. But that, too, is redundant. Covered both. No regression difference. Looked at ASM. 8080 code has the latter (equiv to ~752) but not the former.
------------------

Wed, Oct 18
It seems to me that rem() should eat newlines, but lit() should not. Checking ASM on this...
	True for ASM. Incidentally lit doesn't pass over leading \t's, just blanks.
	8080 rem:  ;skips over remarks and/or end-of-lines in any order.
	C rem: advance of multiple newlines, then over multiple comment lines
	8080 lit: advance over blanks, then over literal if present. Hence always stays within a line.
	C lit: passes over all white space, including \n's.
Fixes (C) needed for both.
Changed the code. Tests 41,42 still error 9. And 41 does not print 23456.
41: 
	Factor still looking at ]. After parsing "MC c,1\n" arg decls AND the \n.
Time to audit rem vs lit usage. Too many rem's can be the cause.
	8080 rems:
		term	1149
		skipst	1312,19,35,48,81
		st		1421,28,32,43,1508,36
		enter	1657
		link	1771
	C rems:
		skipst	674,77,84,91
		st		739,43,802
		enter	999
		link	1069
Notable is 8080 term's special code to assure the / does not belong to /*. C code doesn't have that...
			TE3     CALL    REM     ;make sure no /*
			        LXI     D,XSLASH        ; /
			        CALL    LIT
			        JZ      TE4   <<-- jump to % test
			        CALL    FACTOR
IS SUE Fix needed. This however is not 41's problem. It has no comments except at the very top. 41's problem is in enter, trying to parse more stuff after parsing "MC c,1" in the lib.
			putchar char c [
				if(c==0)c='"'
				MC c,1
			]
41 is crashing on 1st statement, putchar 10. If covered 41 runs to completion doing pft perfectly (prints "23456") but error 9. Multiple problems here. What to do first???
Proper addrval. DONE. 

Tests 30,31,40,41,42 now show error 9.
Committed. 
-----------

Oct 19
Goal: fix all those tests.
	ALL BUT 41 fixed. The fix is not a faithful to the 8080 fix, but instead a rem statement in st()'s compound statement for loop at ~766. The 8080 code has a later rem, but also calls rem AFTER most statements. Excused from the responsibility are leave, break, and return. Maybe I will have to revisit this quicker fix. Here are some learned lessons...
		Does st() in general rem when done? 
			For C "NO". 
			For ASM sometimes, generally YES. For leave,return,break it does not but the cursor is reset anyway. For if, while it does skipst which does it for them. 
		Does MC? 
			For C "NO". 
			For ASM "NO".
		C: When enter returns the cursor is restored to just behind the ), to the semi. st called from cmpd eats the semi. Doesn't rem it. cmpd rems it,  
		Compound is the ONLY tc multiline statement. 
		Uncovered the first rem in cmpd (~766). If my understanding is correct that should clear at least the test 30 issue, and maybe the others.

Next goal: test 41.
	prints "23456" as designed, using lib function pft from,to. Moving the ] to the end of the line with pft b+2,b+6 solves the problem. So its really the same as the above, BUT a rem call is needed after the b+6 is parsed. So the quick fix above is a partial, not total fix.
b fundone, enter~1050, after cursor is restored. 
	It is restored to -> b+2,b+6 which were parsed way back at the top of enter. line 990 should be moved to after all parsing. MORE TRACING, first.
	ASM code pushes stcurs,cursor onto 8080 stack, and restores them at the end. pushes are just before cursor=where, and call to newfun. 
FIXED.
------------

Friday, Oct 20
Coded test 43 which covers a lot.
	segs: FIXED null string bug (pl""). Regression GOOD.
	segs: num. cursor->" char b(10),int v(0))..." (num decls)
		in enter, ~1042, seg is in addrval ~431.
			~11 is covered, so ndigits not in vartab, addrval SEG's instead of erroring out. Uncovered 11
		b ~1042, enter before st().
			where->" char b(10),int v(0))..." (num decls)
			LOOKING FOR why did it seg
			c: in addrval~431, no parsing since above
			OPPS: forgot to save test fix. 
	no seg, completes...
		num returns 0 digits, 0 value.
		at enter ~ 1042, about to call st, cursor->"v(0) [\n...". The second arg didn't advance the cursor. enter does the parse. It did two passes. 
		Read the Owners Manual. Function arg decls are like local decls. A single type is separable by commas behind char OR int. But if both types are used use a ; or a \n between the tyypes. E.G.
			int num char string(0), int val(0)  IS WRONG.
			int num char string(0); int val(0)  is good as is...

			int num char string(0)
					inv val(0)
			
			on two lines.
------------
8080 code frag, enter, arg decl parsing...
		EN4 
for(;;) {		    
				CALL    REM     ;parse arg decls and pass value
 rem()
		        LXI     D,XINT  ;works just like DECL, except
		        CALL    LIT     ;  uses SETARG instead of
 if lit int
		        JZ      EN5     ;  VALLOC.
		EN6     LHLD    ARG
  do {	
		        MVI     B,'I'
		        CALL    SETARG
    setarg
		        LHLD    ARG     ;bump ARG pointer to next
		        LXI     D,5     ;  stack layer
		        DAD     D
		        SHLD    ARG
    ++arg
		        LXI     D,COMMA
		        CALL    LIT
		        JNZ     EN6
  } while(lit ,) 
		        LXI     D,SEMI
		        CALL    LIT
  eat lit ;
  		        JMP     EN4
		EN5     LXI     D,XCHAR
  ELSE if lit char {
		        CALL    LIT
		        JZ      EN7
break from en4 loop  same logic as above
		EN8     LHLD    ARG
  do {
		        MVI     B,'C'
		        CALL    SETARG
		        LHLD    ARG
    setarg      LXI     D,5
		        DAD     D
	++arg
		        SHLD    ARG
		        LXI     D,COMMA
		        CALL    LIT
		        JNZ     EN8
  } while lit ,
		        LXI     D,SEMI
		        CALL    LIT
  eat lit ;
		        JMP     EN4
}
		EN7
-------------------------
What it should do (enter, EN4..EN7)
for(;;) {		    
	rem()
	if lit int {
		do {	
		    setarg
		    ++arg
		} while(lit ,) 
		eat lit ;
	}
	else if lit char {
	break from en4 loop outer same logic as above
		  do {
		    setarg 
			++arg
		  } while lit ,
	  	eat lit ;
	}
}
What it does, ~1014..32
		for(;;) {	  
			rem();
			if(lit(xint)) { 
				do {
					setarg(Int, &stack[arg]);
					arg++;
				} while(lit(xcomma));
				lit(xsemi); /* optional */
			} 
			else if ( lit(xchar)) {
				do {
					setarg(Char, &stack[arg]);
					arg++;
				} while(lit(xcomma));
				lit(xsemi); /* optional */
			}
			else {
				break;		/* and the only way outa here */
			}
		}
--------------------------
Saturday, Oct 21

Subtle difference. Hard to see. It's the break. E.g.  int x; char y 
leaves the for loop with the char unparsed. 
Runs to end. Error 6, RANGERR. 
Len of b(10) is ???. Addressing b(1) fails. num code is faithful from pps lib. vartab has a b with len 1. frag from vartab...
	name = "fclose\000\000", class = 69, type = Int, len = 1, 
    value = {uc = 23 '\027', ui = 6334231, 
      up = 0x60a717 <pr+3319>}}, {
    name = "v\000\000\000\000\000\000\000", class = 1, type = Int, 
    ==>> len = 1, value = {uc = 0 '\000', ui = 6334720, 
      up = 0x60a900 <pr+3808>}}, {
    name = "ndigits\000", class = 0, 
    type = Int, len = 1, value = {uc = 4 '\004', ui = 6334724, 
      up = 0x60a904 <pr+3812>}}, {
    name = "b\000\000\000\000\000\000\000", class = 1, type = Char, 
    ==>> len = 1, value = {uc = 11 '\v', ui = 6334475, 
      up = 0x60a80b <pr+3563>}}, {
    name = "v\000\000\000\000\000\000\000", class = 1, type = Int, 
    ==>> len = 1, value = {uc = 0 '\000', ui = 6334720, 
      up = 0x60a900 <pr+3808>}}, {
    name = "k\000\000\000\000\000\000\000", class = 0, type = Int, 
    len = 1, value = {uc = 13 '\r', ui = 6334733, 
      up = 0x60a90d <pr+3821>}}, {
lib frag...
		num char b(10)
		    int v(0) [
	That violates C, passing a big thing. Have to pass b(0). BUT tc's lib (app c) has same. And it addresses b(k) for k>0. And evidently works. Somehow in ASM the pointer only gets passed. But the declared len prevails for range checks. So gotta read a bunch of code. Setarg calls valloc to do the work. Setarg loads registers used by valloc. And valloc calls newvar to do some. And newvar calls copyArgValue.
C version...
	setarg
		Called when enter has JUST parsed char|int. Passed type and stack entry from 1st half of entry().
		Gets value,size,class BUT NOT SIZE (commented out), not len (not on stack), resolves lvalue 'L' to 'A', passes all to valloc.
	valloc
		given type,vpassed, parses the (dimension) if present. Adds vclass, alen to the args sent to newvar.
	newvar
		fills in new var's vartab entry, using 4 params plus canon. allocates space and copy's arg.
	allocSpace
		allocates and zeros space
	copyArgValue
		does the get/set of JUST the value
ASM...
	setarg
		loads reg's with class,lvalue,size(really type of arg), stuff (value,2 bytes), resolves lvalue to 'A', uses size to propogate sign into int, Passes all (incl type of DECL specifically) to valloc.
		NOTHING ABOUT LEN. Len not even in available data. Valloc will uncover that.
	valloc
		Parses name, (size) if present, stores len in ALEN, loads reg's with type,class,ALEN,obsize,passed calls newvar.
	newvar
		same as C.
It is evident the C version fails to pass ALEN to newvar and/or newvar ignores it if it gets a passed value. Probably the latter.
--------------------
Sunday, Oct 22

Goal: fix the above, get 43 to run to completion, commit.
Strategy is to trace enter from its middle (parsing arg decls). LOOK FOR alen being tossed aside.
	Parsing lib: num b(10), vartab[26]: len=1 when out of setarg tc~1027. Damage is done.
	b setarg, run 43: cursor->" b(10)"...
		b valloc, c: vAlloc(Char, onStack)
		stack: 1 'L' Int vartab+792 vartab[24.75]
		vartab[25] is ndigits
		vartab[26] is empty (nxtvar=26)
		cursor->" b(10)"
Found it. vAlloc vpassed ( case sets alen=1, then mustFind ), which SKIPS OVER the 10). No call to parse the 10. 
Review of ASM for same case: 
			if lit (
			asgn
			lit )
			alen=toptoi()
Test 43 completes, but clearly bug in lib num ~53, FIXED, if stmt missing.
Now atoi("-77") returns 77. FIXED, ; needed in args decls
---------------
Wednesday, Oct 25
Last 3 days explored github, and how to upload stuff there. Separate notes: gitNotes.txt. DONE. This project posted at...
			github.com/tgibson37/tiny-c

Next goal: more library functions. Status (x means done, n means next)...
-----------------------
Thursday, Oct 26
Fixed bug in num. 43 not good.
Coding 44, testing move,index,ceqn. 
	move code is faithful tc from 1977, but fails due to range testing arg char a(0) with index 1. So '77 didn't range check? 
		        INR     B       ;obsize in B
		V7      LDA     VCLASS  ;class in A
		        LHLD    ALEN    ;len in DE.
		        XCHG
		        LHLD    VPASSED ;passed in HL
		        JMP     NEWVAR  ;call/ret, NEWVAR allocates the
		;                          variable


Possible FLAW in newvar. It allocates space UNCONDITIONALLY, so passed pointer to already allocated space causes allocation. When it was just b(0) mattered little. But now with range checking fcn parm decls have >0 dimensions. C PASSES ONLY LITTLE THINGS. Decls cannot have >0. And range checking should not apply to b(k) when arg declared as b(0). I think range checking is new C feature. Probably should rip it out. OR a special exemption for arg decls with (0) ??? DID THAT.
Tests 40..43 changed num & atoi args to b(0)'s. Tests OK.
AND the unneeded allocation is now harmless.

44: error 26, symerra, not found. vartab has [30] s4, the last decl in 44. Then [31...] n,b,k. How did a get changed to n???
watch vartab[31].name. set to a. set to n. bt: eq~112:
			put_int( (*lval).value.up, iDatum);
And vartab[31] has a VALUE 'b'. 
---
All this may be caused by still unit testing link();st() without using cold start. MAYBE it is time to switch testing to properly loaded/inited/entered main programs through cold start.
	./tc enters the native loader, >>> prompt, no help. Lets add help. DONE.
looping in link ~1119,16,16 calling lit, endlibrary, /*

TODO:
	STATUS file into github with TODO section
--------------------------
Friday, Oct 27
Time to add args at least into tc.c, and ultimately into tc's main().
I need args for debugging, specifically to use the loader or not, to auto load the lib and/or tc files. Gotta get through warm into cold.
Need to design all this. Starter man...
	./tc			usage
	./tc <files>	load lib as global, pps as system, and 
					the files as app. Skip the loader. Auto go.

Do away with hot/warm/cold start AND the loader. Do it all with command line. 
		Usage: tc [file1 [file2]]
		  no args prints this usage
		  one arg loads the standard library, and file1 as app
		  two args loads file1 as standard library, and file2 as app
		The app will be started at its main() function
		  (no arguments to this main()
new tcMain.c is reading files. Needs: 
	init all the globals. 
	link
	write _MAIN() after endlibrary statement in library.tc
		it calls (MC 11) main() which should be in the app else error
		The apps are now full tc programs, tests 50 and up.
	start _MAIN: cursor=pr; st(); 
	
not all chunk 9 stuff moved to tcMain.c yet. 
loader Load getLine all no longer needed.
--------------------------
Saturday, Oct 28
symname: A symbol can now have one leading '_'.
system main is now _MAIN() vs app main still main().
STATUS 5:38pm, EDT, WE MAY BE DONE!! 
	- tcMain.c now boots the whole thing, prints the logo, starts the system, which enters app main(). IT WORKS. We can now write whole programs as tests.
	- Our first whole boot test is testFiles/50, and we start a new series with that number. The test prints one line.
	- Of course we are not done, lots of testing yet to do. BUT MILESTONE ACHIEVED.
Goal: integrate tc into test.c... 
	- clone tcMain.c as test setup function, one arg is test file to load and run. 
	- Advantage: tests written as whole tc programs become part of the regression testing.
		case 50:
			testWhole("./testFiles/50");
			break;
Integration works. test 40 segs, probably a test setup flaw. So now we turn it into test 51, with a main. Let it seg there.
41,42 still seg, even with cursor=pr added to setup. 51 works when setup is done by testWhole, but it seged when using testSetupFile. So the problem is testSetupFile. Something missing. curglbl is 1, not fun+1; 
FIXED. Now 41,42 error=26, no prints. 42 worked once, 43 never finished.
Make them 52,53 tomorrow.
41: looking up 'char'. enter where->" char c"
-----------------
Oct 29, 2017
Goals: 
	move 41,42 to 52,53 and see if that fixes them.
	When fixed do regression, including the 50's.
	When that is fine, COMMIT, and PUSH.
		Write a STATUS document, short, one line per entry.
Then start full system testing.
Once solid tidy the code...
	Use pointers for nxtvar, nxtstack, and fvar,lvar in funentry.
	Only one series 40 test survives, 43. Others moved to series 50. All run fine.
	Time for full regress... ALL GOOD, keep
		Before leaving this test thingy for next goal...
DONE			Test 35 needs keyboard input. Full regress shows NO prompt, but freezes. Confusing if not familiar. Plan to move ALL tc keyboard input tests to their OWN series, 90 or so. And never regress them, ~3 of test.c staying out of their series.
STATUS: 
	good_results now go through test 53, all good. 43 is only survivor in the 40's test series. Others moved to 50's series. Test 35 is now 99, the new 90's series reserved for manual interaction. Local committed.
push from local git to github, and branching here and there: STUDYING
	~/Projects/tiny-C_new.local has gitHubNotes.txt.
-----------------
Monday, Oct 30
git push origin master  --  DONE

FUTURE note: Do all new work in a local derivative of master. Keep r&l master's sync'd. DONE: do work in local branch Classical, now.

Immediate goal: 
x	Change HEAD to new 'Classical' branch, 
	When more of lib is done commit to github AS Classical, 
	Do whatever the push thingy is that invites people to comment.

DONE (in Classical branch): STATUS.txt created, and added.

Back to classical lib:
x	putchar char c [
x	pft char from(0),to(0)[
x	ps char b(0)[
x	pl char b(0)[
x	alpha char a [
x	num char b(10), int v(0) [
x	atoi char b(0), int v(0) [
x	pn int n [
x	ceqn char a(0), b(0); int n
x	scann char from(0), to(0), c; int n(0) [
x	index char s1(0); int n1; char s2(0); int n2 [
x	countch char a(0), b(0), c [
x	getchar [
	gs char buffer(0) [
	gc [
	gn [
n	movebl char a(0), b(0); int n [
n	move char a(0), b(0) [
	readfile char n(0), w(0), l(0); int u [
	writefile char n(0), b(0), e(0); int u [
	fopen int m; char n(0); int s,u [
	fread char a(0); int u [
	fwrite char f(0), t(0); int u [
	fclose int u [
		/*endlibrary
---------------------

Tuesday, October 31, 2017
and Wednesday, November 1

Big 2 day struggle, pointer passing. FIXED. Test 54 (ceqn) showed the bug. When fixed in setarg ceqn itself worked perfectly, no bug there.

Test 54... ceqn,scann  COMMITed

Other goals: nice tc diag when error set, using stcurs, curs, and countch(...,'\n') to find the line. Code probably exists in pps.
----

Thursday, Nov 2
Commit to github...
	[ref:https://help.github.com/articles/pushing-to-a-remote/]
		$ git push origin Classical
		$ git branch -a
		* Classical
		  master
		  remotes/origin/Classical
		  remotes/origin/HEAD -> origin/master
		  remotes/origin/master
	GOOD, now have remote Classical. I think simple 'git push' keeps BOTH branches up to date. How to check for ALL differences...
		ref: q
		git diff master origin/master
	Silent result after push's. Need to change & local commit something to see if it really worked.
		edited and committed this file into Classical, then 
			 $ git diff Classical origin/Classical
		and got nice diff. 
Next goal: WHATHAPPENED, then MORE lib stuff: 
whathappened: in 8080 the pps had its own cursor for both editing and running. MC 11 pushed 4 state vars, toptoi 4 times for new appl state vars, did the appl (prbegin,st,prend), restored stuff (MCEN2 ~2432), pushzero, done.  
The call to MC 11 is in pps, start, top of last page in OM. Upon return assures cursor in app range, computes lineno, couple of pl"", prints either "stopped" or whathappened.
-------------

Nov 3
Doing whatHappened() ~1256. Called tcMain.c ~28.
DONE: Translating error code into words would be nice. DONE, prints SYMERRA for example.
Test 55 is purposely wrong, to show up error case. 3 undeclared vars, bombs on the first. And be sure to avoid leading tabs on a line to see the TRUE diag.
countch, tc.c ~1248
added some english words to the error code symbol ~1280... .
-------------

Nov 4
Gonna commit and push. DONE
-------------

Nov 6
Back to classical lib. Some thoughts first. Doing the classical stuff is fruitful MAINLY for debugging, and getting used to command line instead of the 8080 loader code. So we do this. Maybe pps. 
But my REAL thought is to make this useful I should do a MODERN version: proper C syntax, and some kind of wysiwyg editor. Easiest way to that route is find a GPS editor and just add a "run this" macro to it.
Playing with gedit's "external tools". 
	open terminal here works...
		~/tryIt  dir, saved a file there so it was "current directory"
		set ^t as shortcut
		^t  :  term comes up with '~/tryIt $' prompt.
	run command: works but sends outputs into current document
	scripting: #!/bin/sh at start of the 4 supplied
	edit options include what to do with output, fast key, more
	zenity is used to implement 'run command'. Its a bash scriptable dialog  with lots of choices. Small dialog popup.
	Read the code for 'build'. Does a make, but has useful $DIR feature. 
		$dir's to the dir of the current file in gedit, makes that file, $dir's back. So you can edit in one dir but make in another.
	I need to do a bashscript for ./tc. Its gonna be a project to make it a smooth substitute for pps. But its the most direct path to wysiwyg.
	I think I'm happy with the interpreter. There will be a bug or 3 still to find. But LOTS of code to interpret is the best way to find them. And an nice wysiwig editor is the best way to produce lots of code. So my evening thinking today is: PRIORITY, wysiwig. Best opportunitY: go for gedit/externalTools.
Done so far...
	executable tinyC is in /usr/local/bin
	./tc.sh <args> runs it  [local shell script in Projects/tiny-c]
	gedit external tools has /usr/local/bin/tinyC $*, BUT...
		$* doesn;t work. Can't pass args. 

-------------

Tue, Nov 7
Defined two gedit external tools...
	tinyC-Current: 
		save current page, then execute it, outputs to bottom pane
	tinyC-Append:
		execute file[s] named in popup, outputs appended to current document
Debugging these: copied files to /usr/local/bin/tinyC and /usr/local/share/tinyC/library.tc. NEED TO ADD install target to makefile.
Append still doesn't work. But I committed, and merged back to master, and pushed.
-------------

Wed, Nov 8
Thinking about varargs. How is this for the library...
	printf char fmt, varags [MC 101] 
That is the entire entry. The where points to varargs, which today points to either int, char, or [ (or the spaces before them). 
enter() has parsed args onto the stack. When it sees 'varargs' it parses it as an int, then calls MC. Else-if lit varargs at ~931 does it. The ~936 test needs to be careful. 
MUST the body call an MC? The requirement is the code must pop all the args passed to it and push one return value. machinecall is passed nargs. It calls toptoi that many times. C's printf uses the fmt to pop stuff. Need to emulate what machine call is doing.

Test 57, move movebl. COMMITed. PUSHed.

New goals: 
    remove annoying prints, 
x        MC ~'s 151 156 186.
        system prints
    show the logo JUST once per session. BUT what is a session? 
x    Write a gedit_integration.txt. 
x    Assure github README.md is helpful. 
    Remove the Classical branches.
-------------

Thur, Nov 9
Comments from Lee Bradley:
    useful:
        windows and linux releases
        pps library
        lazy syntax [strong like]
        learn C by translating from tc
    Not so useful
        pps editor
    Mysteries
        makefiles
        gedit users
        MC 14 bug
        doing Ed's enhancements
        
Future Goals: 
    writing: steps to convert tc code into C code
    dash options
        -v  [verbose]
        -d  [debug]
            b,w,p,c,n
     settings
        which lib to auto-load
        sizes of 4 major struct arrays
     cleanup
        Classical should have ONLY classical lib
        pointers for nexvar, nxtstack
        std comment *'s
-------------

Sat, Nov 11
Goals: test getters, File i/o. That completes the classical library
Test 90 test just MC 2, and is not a tc program with a main. It must be run using the test system, ./test.
Test 91 IS a tc program with main, and can be run in the test system OR as a tc program. It tests getchar, gc (the classical), gn, and gs.
    IS SUE: need whatHappened to be tab aware
    Goal: total confustion on test 91, gs.
K&R p160, low level io
-------------

Mon, Nov 13
Yesterday found code for kbhit and getch on the web...
	https://stackoverflow.com/questions/7469139/what-is-equivalent-to-getch-getche-in-linux
	https://cboard.cprogramming.com/c-programming/63166-kbhit-linux.html
Both compiled and worked fine using default gcc. 
TODAY:
	kbhit won't link using makefile even if compiled separately using default gcc.
		It requires the default lib. makefiles -I points to lib it cannot use.
	Can I point ALSO to the default lib...
		ldconfig -v 2>/dev/null | grep -v ^$'\t'  LISTS the default libs
		ldconfig -v prints out all the .so in each lib
ref: https://homepages.inf.ed.ac.uk/imurray2/compnotes/library_linking.txt
	AT the very end...
	"You can see what shared libraries your program is trying to use with:
	    ldd ./my_program"
 $ ldd ./kbhit
	linux-vdso.so.1 =>  (0x00007ffe4f5f5000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fe74ab0c000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fe74aed5000)
 $ ldd ./getch
	linux-vdso.so.1 =>  (0x00007ffd12381000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fdd56a57000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fdd56e20000)
So now we know what libs have to be included for those two. 
SYNOPSIS
       gcc [-c|-S|-E] [-std=standard]
           [-g] [-pg] [-Olevel]
           [-Wwarn...] [-Wpedantic]
           [-Idir...] [-Ldir...]
           [-Dmacro[=defn]...] [-Umacro]
           [-foption...] [-mmachine-option...]
           [-o outfile] [@file] infile...
IS SUE: will this help us with FileRead.c, and time.c !!!
Need to add those using -L's. 
	-Ldir   Add directory dir to the list of directories to be searched for -l.
	BUT what dir has libc.so.6, or linux-vdso.so.1   ??? 
		$ ldconfig -v 2>/dev/null > junk
		$ less junk
		:/libc.so.6   ==>>  scroll up to see its directory...
	libc.so.6 is in 
		/lib/i386-linux-gnu	
	/lib64/ld-linux-x86-64.so.2  is in  
		/usr/local/lib  AND  /lib/x86_64-linux-gnu
	the -vdso is not found.
BEST BET: libc.so.6
	$ ldd tc
		linux-vdso.so.1 =>  (0x00007ffdfd2ac000)
		libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4208c17000)
		/lib64/ld-linux-x86-64.so.2 (0x00007f4208fe0000)
WHICH is already searched. Chasing the wrong path. Why does link fail if trying to include kbhit.
TRY JUST getch...
	default compiled
	added getch.o to makefile ~20
	make  ITS HAPPY
	added kbhit.o to makefile ~20
	make  STILL HAPPY
Test 91 calls them, clones the supplied kbhit.c's main(). ALL GOOD!
MYSTERY: ~2226 above, why did it not link back then. The issues seems to have just melted away. Probably a misdiagnosed cockpit error.

SIDE NOTE: Esc to kill an app will give a whatHappened. Better than ^C.

Test 92 clones test 91 in tc using chrdy instead of kbhit.
	sleep 1 is not parsing, the MC gets a 0 arg. 
	92 frag...
				while(chrdy()==0) [
				  sleep(1)
				  ps("Press a key... ");
				]
	lib...
				/* sleep for n seconds
				sleep int n [
					MC 102
				]
	MC 102...
				/* sleep for N seconds */
				void Msleep(int N) 
				{
					sleep(N);
				}
	gdb on Msleep...
				Breakpoint 1, Msleep (N=0) at machineCall.c:165
				165		sleep(N);
Variation, sleep 1 in 92:7
I want to breakpt tc code 92:7, the sleep(1) statement. THEN b tc.c parsing that line. dumpLine() has cursor on non-blank. So match 5 chars.

break doesn't work ~749(zero), 762, 799, 802, 829(set), 
I cannot get the cursor past the if to its break statement. I need to set a tc break. A bit of code at tc.c first lines TRIES to break on the sleep fcn call. Therein lies a clue to a table of such breaks.
-------------

Tue, Nov 14
Yesterday started coding debug.c.
Today: not committing often enough. Last commit Nov 8 before changes to getchar, and probably others. Regression runs 57 tests with a few diffs...
	11, 12, 16
But these are all changes to pr[] indexes. So probably not an issue exceept as cleanup. NO KEEP yet, but commit anyway???
git diff...
	machineCall.c adds: Mchrdy, Msleep
	makefile: getch.o, kbhit.o
	library.tc: corresponding stuff 
		GETCHAR was MC 2, now is gc  WorkInProgress
	tc.c, bugout changes (stbegin, etc)
	test.c, 
		test 35 partial restored, 
		56,57,90's new
I think a local commit will be ok. It compiles and runs.
DONE
---
Back to debug.c
GOALs: set a breakpoint and stop in hit. THEN continue and next.
Coded: 
	whatHappened: leading tabs ok
	args: using optargs in tc.c, hand coded in test.c, modified readTheFiles
	debug.c infrastructure, no action yet
Arg changes work for ./tc testFiles/56 (arb picked whole prog)
whatHappened changes DONT work. FIXED.
Tests 44 new (whatHappened) works
test 93 still broken
Both getchar and gc use MC 2, which blocks UNTIL <enter>. Then they each return one char, INCLUDING the newline at the end. One of these should use getche. 
Mgch MC 2 calls C's getchar. This is what we are trying to replace. This and chrdy which is MC 12.
But test 92 uses chrdy and getchar and getchar there seems to flush the buffer.
CONFUSION: I DONT KNOW WHAT MY TESTS ARE DOING...
	44 ceqn, index, move						???
	45 whatHappened test of leading tabs		good
	91 is a unit test of kbhit/getchar			problem
	92 clone of 91 using lib's chrday/getchar	interesting
make dotest; make diff...
	11, 12, 16 pr indx diffs
	44, whole new test, 
		old was ceqn,index,move; 
		new is empty case
		???
	45 changed, old empty, new whatHappened
	55 must be whatHappened. carrot moved by ONE place
	57 LAST
So what happened to ceqn, etc ???
------------

Wed, nov 15
	44 tests just move
	54 grep ceqn 9 hits. Runs. ceqn,scann
Missing "should get"
	44 45 FIXED
COMMIT locally, including lots of txt files.
 
93 error 21, ARGSERR, args don't match.
	Also getchar and gc 
		both block AND 
		both read the newline AND 
		neither flush the input buffer but read whatever is left over
		both use MC2, which is implemented with C's getchar
	BUT test 92 loops printing "Press a key... "
			kbhit and getchar, ctrl-C to stop
			Press a key... 
			Press a key... z
			Press a key... You pressed z
			Press a key... 
			Press a key... x    <<== echo???
			Press a key... You pressed x
			Press a key... 
			Press a key... ^[[A
			Press a key... You pressed You pressed [You pressed A
			Press a key... 
			Press a key...  <<== <enter>

			Press a key... You pressed 

			Press a key... 
			Press a key... ^C
	redundant "Press a key... " removed.
	It does not wait for enter
	kbhit code does 
		getchar, 
		tests for EOF -> return 0
			else ungetc char and return char
		So tc's getchar gets the pushed back char.
		kbhit works because its getchar ALWAYS returns something
			EOF or buffered char. 
			It modifies stdin's attrs to non-canon no-echo.
		Ref: https://en.wikibooks.org/wiki/Serial_Programming/termios
			Canon/non-canon defined near the end.
Why 92 works...
	The ungetc in kbhit ASSURES the test 92's getchar succeeds.
	It is pushed back into a buffer with no \n.
	And kbhit's getchar was set to echo free (I think).
		What produced the echo's???
		We can live with the echo.
93 ARGSERR several bugs---FIXED
COMMIT local

 library functions x means tested...
x	putchar char c [
x	pft char from(0),to(0)[
x	ps char b(0)[
x	pl char b(0)[
x	alpha char a [
x	num char b(10), int v(0) [
x	atoi char b(0), int v(0) [
x	pn int n [
x	ceqn char a(0), b(0); int n
x	index char s1(0); int n1; char s2(0); int n2 [
x	countch char a(0), b(0), c [
x	scann char from(0), to(0), c; int n(0) [
x	move char a(0), b(0) [
x	movebl char a(0), b(0); int n [
x	getchar [
x	gc [
x	gn [
x	gs char buffer(0) [
	readfile char n(0), w(0), l(0); int u [
	writefile char n(0), b(0), e(0); int u [
	fopen int m; char n(0); int s,u [
	fread char a(0); int u [
	fwrite char f(0), t(0); int u [
	fclose int u [
		/*endlibrary
No x is the TO DO list.
---
Thoughts on getchar/gc
	One of these two should offer non-blocking no-echo. 
	The code in kbhit shows how to do that. 
	Clone that code.
	Which? 
		I think in OM getchar gets the nod. gc should use existing MC 2. 
			OM ~2-22 
			gc: reads a line. 
			getchar: returns even control char's. No explicit mention it
				is non-blocking. But it definitly was.
	Right now getchar calls gc, gc calls MC 2. 
		New MC needed, MC 103. 
	IS SUE: getchar should NOT echo. 
		Is 'ECHO' a proper flag name??? It's not suppressing the echo.
			ECHO is the flag name. 
			Bit or (|) is proper. 
			tcsetattr defininely sets the new state, as ICANON is unset.
------------

Fri, Nov 17
Thoughts on debug
	b <sym>: 
		Look up sym in globals
		check it is class E
		add ptr to its var into brktab
		new bugout call: void entering(where) from enter
				called only when [apr<where<epr]
			entering where matches where to each brktab entry
				no hit -> continue
				else void hit(var)
					hit does debug command loop: 
						n -> nxt statement
						c -> continue
						p <sym> -> look up and print value of sym
	Also when fundone happens nxtfun pops and locals go out of scope. So if I ever do locals, need to pop nxtbrk until all that fcns locals gone. Probably need same arch as funtab.
---
Working on debug. 

refactored addrval, nicer code, usable part _addrval searches one level.
changes in tests 45 tab tolerance intentional, 55 
	(old err SYMERRA 26, new err SYMERR 3) Both are decl needed.
	SYMERRA only shows in test.c comments, and tc.c errToWords.
	tc.asm has it in addrval for failed lookup. 
		Had it in C version. Evidently returned zero.
		Lost it in this refactor. Still returns zero.
		test.c always tests and prints "addrval returns 0"
		tc.c only one call, it tests, 
			it eset(SYMERR) which DOES NOT override previous setting.
	SYMERRA is dead. Leave the code as is.
	tc.asm use of SYMERR: factor tested for 0 where which should never happen.
	C code makes no such test.
b will be on globals only.
	on 'E' its like gdb b
	on class 0,1 its a watch
fgets fails on stdin, "iofgets.c: No such file or directory." 
	Try gnu extension...
	Function: ssize_t getline (char **lineptr, size_t *n, stdin)
That fails, too.
------------

Sat, Nov 18
Working on debug.
Still cannot read a line, fgets internal issue.
	sudo apt-get install libc6-dev
	and maybe build-essentials
		various help sites say this fixes various lib issues.
	Separate compile of debug without CFLAGS fixed it. 
	Evidently ../syslinux/com32/.. has many problems with i/o related stuff:
		FileRead.c getch.c kbhit.c debug.c(because of fgets) time.c
	The main 5 are happy with the -I
Spent the whole day on this issue.
------------

Sun, Nov 19
Working on debug. Status...
	reads command lines now
	parses them
		b builds entry in brktab
DONE		But need to test for valid symbol
		i dumps bldtab in readable fashion
DONE	FIRST mod the makefile to debug compiles without CFLAGS
More thoughts on debug
DONE	Add lib syms to b, but when you hit n or c screen for app code. 
x		Idea is this: 
x			test 56 has no globals, but lots of lib calls.
x			so b libsym is useful, but tracing lib statements is probably not
x	OK next is run and 
x		stop on brk pt
x		display the line
x		enter commands
	What tc code defines fname,lname? symname IT ADVANCES THE CURSOR
yes	Does canon then put it in string form? 
no	In any buff? Only a struct var
		~436 void canon(struct var *v) {
This looks handy...
	/* return true if symname matches arg, no state change (new) */
~262	int symnameis(char* name){
			int x = strncmp(fname, name, lname-fname+1);
			return( !x );
		}
symname() should not change state. fname,lname are not state. Only cursor.
	/* Parse a symbol defining fname, lname. ret: true if symbol */
	int symname() {
		while( *cursor == ' ' ) ++cursor;
		if( isalpha(*cursor) || *cursor=='_') {
			fname = cursor;
		}
		else return 0;  /* not a symbol */
		while( isalnum(*cursor) || *cursor=='_'){
			++cursor; 
		}
		lname = cursor-1;
		return 1;  /* good, fname and lname defined */
	}
Should I tidy symname? Return sym size instead of true/false. Advance cursor over whitespace, but not the symbol itself. Callers take responsibility for cursor. So, who calls???
	tc	 
		~603(factor, all syms except decl), 
		700(valloc, parsing decl), 
		975(link, globals)
	test ~182(test 5 on symname itself )
Alternative is capture/restore cursor before/after the call. UGH.
------------

Mon, Nov 20
Tidy symname first. Regression is happy -- DONE.
Algorithm for hit: only looks for token on line. n=index won't catch index.
Instead of strcmp we need to 
	scan the line. OR 
	bugout from addrval. OR 
	put a debug hit field in var, and when set addrval does bugout.
		advantage: simple, can do locals, 
Changes: 
x	tc.h add the field
x	addrval add the bugout call
x	newvar zero the field
x	set_b set the field
x	br_hit will receive the bugout
x	hit() goes away
x	stbegin code moved to prbegin
x	cursor>apr test needed where? br_hit.
NOW BREAKING on line 9 of test 56. NEEDS...
	Hits still 0. 
x	No showLine.
x	Need display commands. 
TIDIED: All use of addrval requires EITHER
	fname,lname defined (addrval)
	canon'd string with sym (_addrval)
		debug takes uncanon'd string from its input buf.
		Need general tools for syms.
------------

Tue, Nov 21
Refactored addrval:
	addrval_all searches 3 areas
	addrval uses addrval_all, and is now 3 lines of code
COMMITed partial debugger.
DONE Goal: Debugger p <sym> prints the value of a symbol
	Tools needed: string with canon'd buf parameter
		symname defines fname,lname. 
			It is tidy, now, doesn't jump cursor beyond the sym.
		canon sets canon'd name into a var. 
			See addrval for usage.
		fname,lname is an OK way to communicate from symname to canon
			they are used in very tight transient ways
			both are char*, so quite flexible
COMMITed useful debugger. GITHUB also.
NEXT goal: time to write a document.
------------

Wed, Nov 22
Goal for today: piranha fish
DONE	typing
	need seed and random in lib
------------

Thur, Nov 23
Decided to put random into the lib. Found the code OM p.3-12 (guess a number).
Debugging....
			line 265 SYMERR, decl needed 
			else if(p<5) ps "hunter"
			   ^             	skipst ???   if ??? ~767
	(gdb) p s
	$12 = 0x40517b "else"
	(gdb) p cursor
	$13 = 0x609da2 <pr+4738> "ps\"move \"\n 
		Cursor at SECOND ps "move  ", pf.tc ~59
NEED s and n(DONE) commands in tcDebug.

lit(xelse...   cursor-->"\n  else ..."
	call to match made and fails. Should lit ALSO pass over newlines???
	Or should if code ~771 call rem???  And how about skipst???
----------
Getting to cursor at if-else-chain of pname...
		gdb ./tc
		b tc.c:774      if(lit(xelse)...
		r pf.tc
		7		[seed request]
		c 3
		s		[move request]
				[bk 1 @ 774 if(lit(xelse)), 
				cursor pr+9638->else if(p<5) ps "hunter... GOOD
				header printed. 
		s		in lit, cursor -> "\n  else... 
				lit-else gonna fail nue to \n
Question: where in 8080 code is rem called. Where are new lines allowed???
1	ASCRET 0DH, usage: rem~673, skipst~1338
2	NEWLINE is ASCRET-NULL, only REM ~660 uses it
3	XNL is same thing,      only ST-TRET ~1515 uses it
4	rem goes over mixed ASCRET-\n-comments, then (via lit) whitespace
5		The most powerful next-token tool
6	skipst rem's before & after everything
7		calls itself for [], if, while
8	st does the same
9		if-else part relies on skipst when done to do final rem

ok now review C code, does it faithfully mimic all the above...
1	'\n' usage: rem~322, skipst~705, (all for this bug)
2	newline not used at all
3	xnl usage: rem, return, enter (that's all)
4	whitespace, newlines, comments
6	before and after
7		recursive
FIXED 8	~775, NOT after if. And after while the rem is commented out.
9		various, just before each return (now)
------------

Thur, Nov 23
Still broke! Same symptom, else needs decl. Missing rem somewhere. 

places to look
	skipst ~1320 ~1333 relies on lit 
	return push zero should test for comment
8080 enter DOES not do rem where I would expect. Neither does C enter.
	BUT arg parse calls asgn~1626 . Does that rem??? I doubt it.
	YES, but down in term as a guard before parsing /. 
	C's term does not. It should, for the same reason. AND incidentally that may be the rem that made 8080 work. Better fix would be in enter before switch contexts.
------------

Fri, Nov 24
WHAT SHOULD HAPPEN, starting with call to ps"cannibal"
	ps parsed, enter()
	arg parsed, ~900
==>>	8080 Deep in arg (in term, specifically) is a sneakey call to rem().
FIXED		None in C.
---
pf.tc now shows status. whosgoing has issues. debug does, too.
	Debug p uses dumpvarentry, such as...
		 var 35: ngoing 0 Char 1 pr[9965]->NULL<-
		 var 34: move 1 Char 5 pr[9960]-><-
	after adding player 1 into canoe. 
debugs p is misleading...
	ngoing 0 means class, then type, len, where, value.
		Useless to a tc programmer.
		NULL is probably wrong.
	move 1 means move is a class 1, not the value is 1. Its a char(4) (five items) array starting at pr[9960] and value is not shown. should be 1 0 0 0 0. 
MAJOR IS SUE: Bombs in the lib need intelligent wha-happn'd.

MAJOR ISSUE: bombs due to forgotten ] means inclomplete link. Need to diagnose that situation and give intelligence that is helpful.
------------

Sat, Nov 25
New bug, LVALERR.
using tc debug UNDER gdb
	setup...
		plant foo=1 in tc code (decl top as global)
		gdb ./tc
		b gdb_b		enables transition from [tcdb] to [gdb]
		run -d pf.tc
		(tc-db) b foo
	session...
		(tc-db) r
		do app dialog if any until foo is hit 
			you are in tc-db...
			n to complete foo=1 statement
			more n's to step to tc code of interest
		g goes back to gdb still running.
			bkpt @ gdb_b
			5 n's get to st() ~758 stcurs=curs
				n or s to step through interpreter code
				c to resume tc-db (assuming only bkpt @ gdb_b enabled)
		x to leave tc for restart back in gdb, 
			run -d pf.tc again
------------

Sun, Nov 26
gdb watch cursor==(pr+8318), NO HIT, but...
	app line 210 (cursor pr[8338])LVALERR, not assignable 
            health(p)=health(p)-2
EITHER the watch didn't work OR the cursor never saw the h of health
Try 8300...
	->"=4) [\n" 12 spaces  ...   if(health(6)<4) ["...
       end of ~208                 begin of line 217
shown by p cursor while linking. 
watch cursor>apr
	exited again, same symptoms. Somehow cursor making a WILD JUMP.
Cannot brk just before the damage, at or shortly before 8318.
NEW plan... run -d pf.tc, b foo, Then single step ENDLESSLY watching the cursor from time to time.
WHAT SHOULD HAPPEN... starting at cursor line 208 first signif (h)
	factor~637,..,647,8,9 examine where, class, type, foo
	step into pushst
		when done stack[0] should be the lvalue
		put watch on its lval
	tunnel out of expr stack
		back to asgn
			parse the =
			asgn
				parse second health(p)
				parse the -
				parse the 2
				subract
				examine the stack here
			eq   <<== we know the stack is screwed up here
{name = "health\000\000", class = 1, type = Char, len = 10, brkpt = 0, 
	value = {uc = 11 '\v', ui = 6337035, up = 0x60b20b <pr+9963>}}

pf.tc~64: Player 1 on keyboard (j) is really player 0 internally (p)

5:41pm gdb; n'd through logic expr pf.tc~208. Stack had 0+0 (+ is OR). GOOD. 
	looking at [ \n health(p)=health(p)-2\n...]
The if at ~204 should fail. 
	Cursor WAS at 8304->[ 4 n's ago.
	n ~477 asgn if(xeq
	n ~482 asgn return
	n ~483 }
	n ~596 factor, must find ) [after the (p) subscript]
	n ~597 		cursor=x+1  [after must find]
		x points to ), BUT its the ) in health(p)=health(p)-2.
HOW DID it get there?
Also we are at st() ~775, 
FLAW IN mustFind(). Shouldnt use epr to end fatal scan. Reasonable limits.
	Need to audit all uses. 
------------

Mon, Nov 27
Two subtle bugs found getting pf to run...
	- The hidden rem bug:
		in term to parse the '/' (divide) the 8080 code called rem first to guard against seeing the / as a divide instead of the start of a real remark. That is a poor logic. Somehow it never caused a problem, though, so it did work. in the C version I missed that rem call. That caused a problem if an if-else...
		lit(xelse...   cursor-->"\n  else ...". 
The \n caused the lit to fail when it needed to succeed. The fix, when finally diagnosed, was a proper guard, after lit('/') explicitly test *cursor=='*' and if true decrement the cursor so it is on the /.
	- The runaway mustFind bug:
New code mustFind() helped in 4 places, ample worthiness. I used it to look for required closing ),],[,and prime. And in some cases (link) it had to pass over text, namely the decls of functions. So I bounded the search with epr, a param to mustFind. This violated the idea that only rem goes to a new line. But that idea was wrong in the one case, link, that needed tofind the body of the function. Unfortunately I bounded it with epr in 3 other cases. A missing ) in pf.tc caused the cursor to find one in the very next line. The cursor was now way off, and the diagnostic was LVALERR. Two days to find that cause, starting with how did the stack get so screwed up.
	Good news: I needed to go more-or-less seamlessly between (gdb) and (tcdb) to find this issue and so the latter got the g command, and I invented the 1=1 technique.

We forge ahead. STATUS pf now does shore events and requests another move. Trifling bug: status doesn't move player or canoe to far shore. Fix is likely to be code failing to change their state (shore,canoe). FIXED

Getting multiple moves, caused by getchar not being getkey. Need to put into lib getkey with replies immediately after the keystroke. New name for what WAS in 8080 version getchar. And in that version gc was the line buffered character fetch which waited for the newline before returning anything. BUT now C's lib has the behavior for getchar. To avoid confusion in 2017 BOTH gc and getchar will be line buffered, and the new getkey will be the keystroke version. OR stay classic? (YES)

Bug: move 1 prints 257 into the boat. Here is more complex sample...
move 1
 257 into the boat
move s
near shore                      far shore
 1 cannibal 
	...
 9 missionary 
     canoe
     257
move 2
 514 into the boat
move s
near shore                      far shore
 1 cannibal 
	...
 9 missionary 
     canoe
			<<== nothing
Two mysteries. 
1	Why the 257 & 514 instead of 1 & 2?
2	Why not both in the canoe instead of nobody?
#1 This is not a pf.tc bug. Another DEEP MYSTERY (ugh)
Evidence...
Code:
  while(1)[
  	pl"move "
    j=getchar
    p=j-'0'
    pn p
...
    else if((j>='1')*(j<='9'))[		/* Put player in canoe
...
      if...
      else [
      	move(ngoing=ngoing+1)=p
      	pn(p); ps" into the boat"
      ]
    ]
  ]
Use:
			move 1
			 1 257 into the boat
			move  -38
			move
How did p become 257??? Time for deep debug.
REASONING: 257=256+1, toptoi returns 0x101 instead of 0x01. Class 0 char should return 0x01. toptoi looks at class and type in two phases: 
Seems a (char) cast is missing somewhere, but evidently not in toptoi, which looks at ALL the atts of the top to decide what to return. Class 0 char seems (by eyeball, not by actual test) to return 0x01. The cast is there, ~132 & 137. But they are complex datum calc, easy to be just a bit wrong. I need to see an actual case work thru these. So far cant find the ACTUAL case that returns 257. 
~143, set a watch on datum==157. Can you watch a local?
https://stackoverflow.com/questions/1354637/how-do-i-set-persistent-and-conditional-watchpoints-on-locally-scoped-variables
A bit complicated, but...
b toptoi
commands
watch datum if datum==257
continue
end
ALTERNATIVE, create a global, toptoi sets the global to datum, watch the global. Use the if in the watch OR put it in the C code...
	if(watchme==257)watchme=datum;
	return datum;
GOT IT! Its pn, caught in machinecall ~221, cursor at ] of pn's body.
nargs=1, that arg is a 247. So who PUSHED 247 onto the stack.
~169, moved watchme here (push).
Now its in eq ~101. Just BEFORE foo=1, and before pn(p). 
      	move(ngoing=ngoing+1)=p    <<== HERE, right on the \n.
		foo=1
      	pn(p); ps" into the boat"
p turned into 257 much earlier than expected.
enuf for tonight
------------

Tue, Nov 28
Try stepping to ~76 and print p.
		(tc-db) p p
		 var 53: p 0 Char 1 pr[10412]-><-
So p=1 when foo is hit. Now in gdb put a watch on pr[10412].
Technique so far allows only one transition from tcdb to gdb UNLESS you plant more than one foo=1 IN ADVANCE. Awkward. 
		(gdb) x pr+10412
		0x60b3cc <pr+10412>:	0x00000101
As an int it is 257, as a char cast to int it is 1. So somewhere the cast is not taking effect (or is absent!!!)

AT symname() cursor->p)  [of pn(p)] single stepping in factor ~626...
	~667, pushst( class, 'L', type, &foo);
	                0    'L'    1   up=<pr+10412> 
(gdb) p stack[0]
$20 = {class = 0, lvalue = 76, type = Char, value = {uc = -52 '\314', 
    ui = 6337484, up = 0x60b3cc <pr+10412>}}
b toptoi, top is stack+24 (stack[1])
	in machinecall 
Skipped too much stuff. Enter uses stack differently, no toptoi. Just pops.
	MC is doing pn, printing the ' ' before the num.
			pn int n [
				MC ' ',1
				MC n,14
			]
	and n is...
			(gdb) x /d pr+10415
			0x60b3cf <pr+10415>:	257
The damage is in enter. In particular in setarg. Actually enter itself, at ~937.
	The ABOVE parses pn(p) and assures the stack has class 0,char. 
		But its an 'L'
	But below it and parses pn int n, AND that results in the call to setarg(Int,...) and hence get_Int to resolve the 'L'. Too late. Need to resolve this up in ABOVE. All parms must be resolved to 'A' up there.
pf.tc runs as before
tests 45~6 has symerr (decl needed)
	45 is intentional error 3, SYMERR
	46 is empty case
test 55 ditto, intentional sym err
DONE	commit this mess!
---------------------

Wed, Nov 29
New thought. Leave basic enter structure, but change the type value so it comes from the stack, not the BELOW parse. Read the code... Entirely in setarg, and much simpler code than yesterdays.
DONE 
	make diff is happy
	pf.tc is HAPPY!!

new BUG: putting second player in canoe fails, empties the canoe. 
		(tc-db) p ngoing
		 var 35: ngoing 0 Char 1 pr[10289]-><-  <<== 1 already in canoe
		(tc-db) n
		line 77 cursor(pr[6332218])->move(ngoin
		(tc-db) p p
		 var 53: p 0 Char 1 pr[10412]-><-       <<== player 2
		(tc-db) n
		line 78 cursor(pr[6332249])->pn(p); ps"
		(tc-db) p ngoing
		 var 35: ngoing 0 Char 1 pr[10289]->NULL<-  <<== nobody in canoe
		       	move(ngoing=ngoing+1)=p            <<== code that did it

No bug in pf. Why did ngoing=ngoing+1 zero ngoing?
HYPOTHESIS: Same bug in eq, putting an int where only a char should go, wiping out its neighbor, ngoing. Looking at mem layout, and ints are 4 bytes little-Endian, writing into move[2] would wipe out ngoing.
Strategy: foo just before above line, gdb b eq, watch pr[10289] (check this) and single step through eq.
~76. Class,type,where,wheresize all based on lval->stackentry.
class 0 0 Char does put_char to *where, BUT then pushk(cDatum) for subsequent use from stack. This AFTER the assign is done. NEED TO WALK THRU THIS.
---------------------

Thur, Nov 30
The eq code, eyeball lookover, seems to handle chars properly. So from yesterday...
Strategy: 
x	foo just before above line, 
	gdb b eq, 
	watch pr[10289] (check this) and NOW ITS PR[10295]
	single step through eq.
	@ eq, doing ++ngoing
		p cursor
		$5 = 0x609f4e <pr+5166> ")=p\n
		gdb) p where
		$6 = (void *) 0x60d9b0 <stack+16>
		(gdb) p class
		$7 = 0
		(gdb) p type
		$8 = 1
		(gdb) p whereSize
		$10 = 1
		...
		94		else if(class==0 && (*val).class==0) {
		(gdb) n
		95			if(type=Int){
		(gdb) n
		96				if( (*val).lvalue=='L' ) 
		(gdb) n
		99					iDatum = (*val).value.ui;
BINGO! why is type==Int? 
typedef enum type {Err,Char,Int,CharStar} Type;
Int is 2. $8 type is 1. 
	~95 TYPO, missing =    FIXED
Now assigns of chars is broken. symptom...
		seed7
		move 1
		move .
		move s
		move 
s prints nothing. Both j and p are undefined, ie character assign doesn't work. The code was NEVER executed before. Lvalue resolution code missing. Added that. Just a guess, for now.
FIXED
CAN DELETE asgnToA() code. DONE
New bug: First try of trip with 2 on board.
		app line 115 (cursor pr[5935])RANGERR, subscript out of range 
			speed = speed + paddle(move(i)*hfactor(health(move(i)))
Same with just one... This worked before. 
	pf~115 ()'s dont match
	FIXED, and this FIXED the RANGERR bug, too.
Another ) typo, ~143 FIXED
All known bugs fixed. Still looking. getchar flaw remains, but the plan is to leave it and provide an unbuffered getkey().
COMMITTED and PUSHED
Browsing a bit...
	http://primepuzzle.com/tc/pf.txt (and parent folder)
		Lots of tc progs in ../tc
		pf.txt is a run by Lee Bradley.
	~2193 above is my first work on kbhit, with ref's to web pages.
3:35pm, Nov 30, 
First full game of piranha fish using new C implementaion of tiny-c. 
	But there is a bug: the score should be 700, not 900.
	And a flaw, excessive move prompts, getchar returns newlines.
debug ISSUE: Need to print array elements.
---------------------

Fri, Dec 1
today's goal: a proper getchar. DONE, BUT...
FIXED	it captures ^C, so how to bail?
Passed all 90's tests involving getchar.
Now need esc capture at beginning of each statement.
	Design thoughts: 
		shouldn't quit if debug is on. 
		maybe do whathappened
		what did ASM do?
			Calls QUIT...
				applvl && chrdy && ESC -> discard ESC, eset(KILL)
---------------------

Sat, Dec 2
IS SUE:survey IS SUE's and summarize in one place.  DONE...
-----
THE WHOLE LIST...
notes.txt...
	502 findEOS() and several other ways: find one way to test EOS.
	517 : Can't we use the same management technique for each stack? nxtvar vs curfun, etc. nxt is the better choice, nxtWEver = wEver; eWEver = wEver+WELEN;
	697 ISSUE better names for globals.
x	709 Subordinate ISSUE is be sure brake and leave are zeroed back appropriately.
	726 : it (77 OM) describes MC calling in detail, specifically MCESET and USERMC stubs. Need to do those. ASM ~2198,2232.
	772 : index base shift, BADDD!, machine call ~110. fix later.
x	2664 MAJOR ISSUE: bombs due to forgotten ] means incomplete link. Need to diagnose that situation and give intelligence that is helpful.
x	2944 debug ISSUE: Need to print array elements.

tc.c...
x	754 quit() /* Returns true if user signals quit.
	 *	STUBBED for now. ISSUE how to set the quit flag from keyboard.
	 */
-----
PRIORITIES
	possible bugs over function over tidy
x		709 2664 
	function
x		754 2944
	tidy
		502 517 697 726 772

DONE Today's goal: Check the possible bugs.
OK 709 brake,leave...
	both are global, 
	brake zeroed at st() beginning
	leave zeroed AFTER st() call near end of enter
FIXED 2664 checkBrackets() scans pr+1 to end up/down counting brackets
---------------------

Sun, Dec 3
Today's goal: function items (754, 2944)
754, quit()
		ESC key hit esets KILL, quit tests for that and returns true/false which causes st() to tunnel to the top. 
		Will it end up in whatHappened? YES, special treatment added.
ISSUE	Or debug? No, but that is probably ok. debug runs UNDER st(). Once st is dead, so is debug. COULD restart by calling the apps main(). OR doing 6 lines from tcMain.c, ~'s 25,33..37

DONE 2944	debug needs to print array elements
---------------------

Tue, Dec 5
FIXED dumpVar uses PrVal which is designed for stack entries. Doesn't display enough for debug p, e.g. doesn't do get_'s. 
FIXED BUG: in tc-db: b health, then b shore ==>> is already 1
	i b ==>> just health, not shore
---------------------

Mon, Dec 11
DONE	Need to design a test for (tc-db)p <ptr>.
		Current design and code: 
			for char*:test *ptr<32 then hex else string. CODED
			for int* always %d. NOT coded   ~141
DONE TEST 94	Test case: must run under -d (obviously) 
		hence natively manual 
		AND natively ./tc (not ./test).
		Three arrays and two datum cover all types.
		Manually p them all.
	DONE, and all 5 tests are GOOD!
---------------------

Thur, Dec 14
FIXED next: bug above ~3022
FIXED new BUG... 	
	p shore prints a blank line, because it is printed as an empty string instead of an array of short ints. debug.c ~122 print_val().
n should stop printing at a newline
---------------------

Fri, Dec 15
FIXED Old (~2955 above) bug...
	Wrong score... Bad setting of h=health(p), ~267
	pf.tc ~267 (wrapup). Data is...
			player =  1 2 3 4 5 6 7 8 9
			health =  0 5 2 0 0 5 0 0 0
	How is health(p) evaluated...
		Problem in eq() ~95..105, fix is new line ~102.
Time to write a document.
---------------------

Sat, Dec 16
Stuff to tidy...
	22 untracked files in dev directory not in master
	How to list tracked files...
		git ls-tree -r master --name-only
		Done: > file 'tracked'
Tests...
x	regression reviews needed: 13 34 43 45 55
---------------------

Sun, Dec 17
good_results date is Nov 29
		4 commits since then.
		Nov 28 is df98eff5713537...
		M == mystery
OK	13: skip (curly braces) prints D (last char on line) But skip works fine.
	Vaguely recall reducing the skip runaway limit by one.
M	34: link, neither the funtab or vartab have anything. But link works fine.
	Recall NO changes in this area. Cannot quickly see why this behavior.
M	43: pl,ps,pn,num,atoi. Again work fine. 
Both M's are error 2, CURSERR. 5 eset's. Both from skip[]'s,
link calls checkbrackets which assumes a real program, not a test of a compound statement. Err 2 is set before any testing gets done. Checkbrackets was introduced to give a more informative diagnostic if a tc program had unbalanced brackets.  
Several little fixes PLUS comment out call from link to checkbrackets. 
New list: 13 OK, 45 OK, 55 OK, 
KEEP, uncover checkbr.. call, New list...
	34, 43 
FIXED: checkBrackets fix, dotest/diff(its clean)/keep, COMMIT, PUSH
No known problems.
---------------------

Mon, Dec 18
	TODO (maybe?)
	Dec 17, 2017
	scan of last 1/3 of notes.txt, looking for ideas over the last 10 weeks.
	Collected here those ideas still alive, plus items worth covering in a writing.
	---

1	never did file i/o in lib
2	Classical branches still exist
3	gedit as wysiwig cannot do dialog (^T)
		does append work? (^R)
4	varargs ~2146
5	malloc's
6	what does verbose do?
7	better understanding of gcc's -I
8	~2977 issues survey, the whole list
	---
9	WRITING
	seed,random now in classical lib (77 was in OM example)
	debug, incl hookup to gdb ~2681, also ~2760
	notes style
		~
		debug notes usually deleted leaving symptom and FIXED note
			BUT not always deleted
		compile and makefile notes
		ABOVE/BELOW refs to code in enter
		sub-thoughts often indented
		broken IS SUE
	90's tests, unit vs whole code, no file vs file
	MC story, how to add your own ~2983
---------------------

Tue, Dec 19
Classifying yesterday's thoughts...
	finish classical stuff
		1 
	documentation
		9
	new function
		4 6 3 
	tidy thiings
		2 5 7 8
and of course more testing. I'm in the mood for #9.

Survey of writings that may help...
	my_environment, about_testing, OM's MC ~2-29
---------------------

Wed, Dec 20
Writing debug.txt. Here are ISSUEs uncovered by the writing...
	debug r should offer restart
	debug d and e
	debug i v (variables)
	prbegin never called, should be AFTER link, so can set brkpts
		goaround: do one n. That lets interp run until it has to parse a statement, which is the MAIN_. By then link is done and you can enter bkpt's.
	debug b, sym must be canonical form
		canonical not called
		adding long sym using long name fails. Adding using canon'd result (mentally achieved) works.
---------------------

Sat, Dec 23
Writing document to gather misc txt's into one odt/doc
---------------------

Mon, Jan 1

TODO (maybe?) collected Dec 17, 2017...

	scan of last 1/3 of notes.txt, looking for ideas over the last 10 weeks.
	Collected here those ideas still alive, plus items worth covering in a writing.
	---
	never did file i/o in lib
	Classical branches still exist
	gedit as wysiwig cannot do dialog (^T)
		does append work? (^R)
	varargs ~2146
	malloc's
	what does verbose do?
	better understanding of gcc's -I
	~2977 issues survey, the whole list
	---
	WRITING
	seed,random now in classical lib (77 was in OM example)
	debug, incl hookup to gdb ~2681, also ~2760
	notes style
		~
		debug notes usually deleted leaving symptom and FIXED note
			BUT not always deleted
		compile and makefile notes
		ABOVE/BELOW refs to code in enter
		sub-thoughts often indented
		broken IS SUE
		90's tests, unit vs whole code, no file vs file
		MC story, how to add your own ~2983
---------------------

Sun, Jan 7
new document "the new classical tiny-C.docx" gathers together stuff in scattered txt files, plus new material. Decided to use links into github for sample programs, archive, maybe other stuff. Can decide those links after doing a tidy-up of the tiny-c directory.
TIDY...
	Archive: txt files EXCEPT the 3 intended for github (CONTENT,STATUS,MY_..)
	SamplePrograms: pf.tc, other stuff in the future
Moved files around, main dir now quite clean. git status easier to read untracked files (mostly .o's).
Committed. Pushed.
THEN decided to be sure it was ok. make install now uses name tinyc, not tinyC. NEW BUGS...
	tinyc with no args segs
FIXED	pf seed 7, 1234.1.1567.1.189. bombs on app line 143.
Doc issues...
	need to advise 2 notyetdone lib functions.
	AND seed and random are lib items now.
---------------------

Mon, Jan 8
Need to survey my scattered txt notes (not in archive) and list their topics to see if any need to be added to docx file...
	about_testing
	gedit integration
MORE IMPORTANT: why is pf broken!!!
10:07am...
	running xpf.tc with b bar, problem game ~3191 above.
	global foo incremented ~141, printed ~142
		foo=foo+1; 
		pl("foo");pn(foo);pl("");
		if(foo>0)bar=1;
	foo = 1, 2, 2, 2   <<== WHY??? Something is resetting foo to 1.
	THEN, last move before RANGERR...
		move 1 1 into the boat
		move 8 8 into the boat
		move 9 9 into the boat
		move .
		Canoe has 84 yards to go, and is 29% full
		A piranha fish has jumped into the boat. He is swimming
		around. He is looking at the toe of the 
		foo 2
		break at line 143 cursor pr[6727]: bar
		if(foo>0)bar=1;
		(tc-db) n
		line 144 cursor(pr[6333805])->pname(p=mo
		(tc-db) n
	WHY the crazy subscript???
		{name = "_MAIN\000\000\000", class = 69, 
			type = Int, len = 1, brkpt = 0, value = {uc = 45 '-', 
			ui = 6330669, 
			  up = 0x60992d <pr+3597>}}, 
		{name = "foo\000\000\000\000\000", class = 0, 
			type = Int, len = 1, brkpt = 0, value = {uc = 99 'c', 
			ui = 6337379, 
			  up = 0x60b363 <pr+10307>}}, 
		{name = "x\000\000\000\000\000\000\000", 
			class = 0, type = Int, len = 1, brkpt = 0, value = {uc = 103 'g', 
			  ui = 6337383, up = 0x60b367 <pr+10311>}}, 
		{name = "y\000\000\000\000\000\000\000", class = 0, type = Int, len = 1, 
			brkpt = 0, value = {uc = 107 'k', ui = 6337387, 
			  up = 0x60b36b <pr+10315>}}, 
		{name = "z\000\000\000\000\000\000\000", 
			class = 0, type = Int, len = 1, brkpt = 0, value = {uc = 111 'o', 
			  ui = 6337391, up = 0x60b36f <pr+10319>}}, 
		{name = "bar\000\000\000\000\000", class = 0, type = Int, len = 1, 
			brkpt = 1, value = {uc = 115 's', ui = 6337395, 
			  up = 0x60b373 <pr+10323>}}, 
      Allocations are fine, no overlap. Note the crazy subscript points into pr at 6333805 == a ui value between _MAIN 0669 and foo 7379. It points INTO the code area, ~145, at the line of code with the crazy subscript. AFTER an n, so it is not crazy, after all. 
      I HAVE NOT YET SEEN THE subscript that is out of range. Presumably it is returned by random.

app line 145 (cursor pr[6763])RANGERR, subscript out of range
  pname(p=move(random(1,ngoing)))
Moved random into pf.tc, now its app code.
                               ^
ngoing 3
IN RANDOM little last range return 1 881932135 3 -1  
r = little + (last/8)%range = -1
       1       88..5/8  3
                  = 110241516.9  (calculator)
                  /3 = 36747171.99  (")
app line 150 (cursor pr[6842])RANGERR, subscript out of range
  pname(p=move(r))
pn little              1
pn last                88..
pn range               3
x = last/8             
pn x                   11..
pn x%range             0
pn little + (last/8)%range     -1
      1   + ( 11.. ) %  3    =  -1
      1   +        0         =  -1

(gdb) p /x (881932135/8)%3
$4 = 0x0

% setting a and b positive violates ansi 99. So the fix needs to be in random, not tc.c. random sets last positive whenever it turns negative, lib ~195, xpf.tc ~304. Could it be the parser does =- wrong? NO. Proved yesterday it works fine.
	if(last<0)last=-last
		IN RANDOM  1 881932135 3 110241516~597 cursor,a,b,pct  6337532:   110241516 3 0
		 0~597 cursor,a,b,pct  6337559:   -20 3 -2
		 -1~597 cursor,a,b,pct  6337592:   -20 3 -2
		  r -1
NEED TO clean up the prints. r printed at ~148 xpf.tc.
ALL PRINTS REMOVED, neg last set positive in xpf's experimental randon(). Bombs as before. NOW do it with clean prints!!!
---------------------

Tue, Jan 9
Clean prints entered, all in xpf.tc. 
---1st RUN interesting excerpts...
Canoe has 10 yards to go, and is 75% full
~297 random: little,big,last 1 4 1977326743
~304: last/8, range, r 247165842 4 -1
--
---~143----
~297 random: little,big,last 1 4 -1895237401
~300: last is now 1895237401
~304: last/8, range, r 236904675 4 0
~145 r 0cannibal.
--
Canoe has 40 yards to go, and is 54% full
~297 random: little,big,last 1 4 821077879
~304: last/8, range, r 102634734 4 -1
--
~297 random: little,big,last 0 1 -1838129039
~300: last is now 1838129039
~304: last/8, range, r 229766129 2 -1
--
---~143----
~297 random: little,big,last 1 3 881932135
~304: last/8, range, r 110241516 3 -1
~145 r -1
app line 147 (cursor pr[6771])RANGERR, subscript out of range
  pname(p=move(r))
                ^
-----
random() is returning -1 often. Usually harmless, just used in if statement. Needed RANGERR to catch this one.
304tidied.txt scrubs the data for a pattern. All the range 4 calls are little=1,big=4. All other calls are little=0,big=range. Most calls are in an if to enter it with probablility...
$ grep random xpf.tc
		  if(random(1,4)==1)onefish
	  r=random(1,ngoing);
		if(random(0,1))[
		if(random(0,1))[
		if(random(0,1))[
	  else if(random(0,1)) [
		if(random(0,2))[
		else if(random(0,2))[]   /* all done for 2/3d's of sick
		  if(random(0,2)==0)[
Recall yesterdays fix worked, but violated ansi 99. So it is the negative? But the negative is fixed at xpf.tc ~301. The % operator has positives.  

Need to see what % does.
---~143----
~297 random: little,big,last 1 3 881932135
~597 a,b,pct -20 3 -2		<<<===  toptoi popped a -20.
~304: last/8, range, r 110241516 3 -1
~145 r -1
app line 147 (cursor pr[6771])RANGERR
---
---~143----
~297 random: little,big,last 1 3 881932135
~304: last/8, range, r
~592  n,d,div 881932135 8 110241516 110241516 3
~592  n,d,div 881932135 8 110241516
~597  a,b,pct -20 3 -2 -1
~145 r -1
11..16 gets pushed by the divide by 8, then -20 gets popped. What happened to put the -20 there??? Need to instrument the stack.
~170 pushk
	(gdb) p stack[1]
	$3 = {class = 0, lvalue = 65, type = Int, 
	value = {uc = -20 '\354', ui = 110241516, up = 0x69226ec}}
AHAH! The value is popped as a character, uc not ui. But toptoi ONLY does ui. And pushk ONLY does 0,A,Int (which stack[1] is. What did toptoi DO???
ANSWER: It popped and used the ui value, then CAST IT TO (char)!!! But ONLY for 0,A,Int. Evidently this is the first case of a large actual being pushed.
Score is 970  --  Whoopee!!!
Clean it up, run final test, commit, update status, push, ALL DONE
Doc issues...
	need to advise 2 notyetdone lib functions.
	AND seed and random are lib items now.
---------------------

Thur, Jan 11
Final draft of document. Proofreading before committing.
Idea: -s "statement" option runs the statement. 
When paper is finalized, rm txt files incorporatedinto the paper.
---------------------

Mon, Jan 22
Adding prototypes to tc.h so it will compile ok with tcc *.c. 
PROBLEM with link()...
	$ tcc -c tcMain.c 
	In file included from tcMain.c:1:
	tc.h:172: error: incompatible types for redefinition of 'link'
	tom@East ~/UbuTom/Projects/tiny-c $ grep link *.[ch]
	tc.c:/* chunk 8: enter, setarg, link
	tc.c:void link() {
	tc.h:void link();
	tcMain.c:	link();
	tom@East
I guess link is defined in some other header??? YES, renamed tclink (3 places) SOLVED.
tcc compiles bug result segs...
	$ tcc -o tc *.c
about 20 warnings, no errors.  $ ./tc
***  TINY-C VERSION 1.0,  COPYRIGHT 1977, T A GIBSON  ***
        This C version copyright 2017, T A Gibson
Segmentation fault
make barfs on test.c. 
	$ make
	make: *** No rule to make target `test.c', needed by `test.o'.
I had moved test.c and tcTestMain.c to subord dir, so *.c would do only tc. MOVED BACK UP. make is happy.
USING gdb to find above seg...
	(gdb) bt
	#0  0x0000000000403e80 in countch (
		f=0x1 <error: Cannot access memory at address 0x1>, t=0x608b26 <pr+6> "();]", 
		c=10 '\n') at tc.c:1290
	#1  0x0000000000403f58 in whatHappened () at tc.c:1307
	#2  0x00000000004055a1 in main (argc=1, argv=0x7fffffffe0a8) at tcMain.c:37
./tc<RET> should do usage.

BUT it makes and tcc compiles, and both run xpf.tc identically. The both seg if no args given. 
ls	after tcc -o tc *.c
	-rwxr-xr-x 1 tom tom 48476 Jan 22 13:27 tc
	after make
	-rwxr-xr-x 1 tom tom   68524 Jan 22 13:32 tc
But the latter has a gdb symbol table. 

ISSUE: regression has lots of differences: 34,43,44,45,50&up

Executable tc is on github, compiled with tcc.
Here is how to compile:
	 $ tcc -o tc *.c   (lots of warnings, I'll work on those.)
And to run pirahna fish:
	 $ ./tc xpf.tc
	 seed 7
	 move 1   (etc as follows)
I move 1234. to opposite shore, the 1. back, then 1567. then 1. then 178.  game ends  score 970
---------------------

Tue, Jan 23
Lee trying to get a goood compile and then run of xpf.tc. Helping him. He gets a seg, and so do I when loading the library specically from commandline...
curfun is 1. Its supposed to be a pointer into funtab, i.e. funtab+1. How can it be 1 NOW? Gotta be in readTheFiles().
It has to be the non-default explicit load.
FIXED! Usual stupidity.

Two goals before joining PG to TC: 
x	regression cleanup, 
x	warning cleanup. tcc DONE. gcc seems way overkill.
One goal before these cleanups: 
x	Make gcc makefile build both executables with explicit link goals
---------------------

Thur, Jan 25
x	All code in tiny-c, no subord dir for the test code
x	Shell script for tcc compile
x	audit docx for install words
	support <cr> in eol
FIXED: undefined ref to usage (tc.c ~1270). probably link order. 
DONE: regression cleanup
NEXT: clear tcc warnings
---------------------

Fri, Jan 26
tcc warning fixup...
x	Machine call warnings
x	tc call warnings, DONE except for unknown escape sequences for '\['
OK now gcc warnings. Change the makefile removing -w
---------------------

Thu, Feb 1
TODO:
	support <cr> in eol
	Multiple lib loading. Need smarter command line to do this.
	Lib fcn to flush stdout buffer.
	implement readfile/writefile
---------------------

Fri, Feb 2
FIXED: ESC fails to leave a loop.
x	test both gcc and tcc
x	regression OK
x	commit/push
---------------------

Sat, Feb 3
Downloaded Lee's double.tc and its input file decl_of_indep.txt into SamplePrograms. 
GOAL is to get them to run. 
x	DONE readfile in the library, and thoroughly tested
x	NEED strlen, bigger pr, main args, 
x		temp: can modify Lee's main and hardwire to text file
---------------------

Sun, Feb 4
AND goal is a better set of command line args to allow...
		personal library (multiple lib loads) -p
		args to main -a
		maybe some verbose dumps -v
			send to file 'trace' with dump limit
		settings -s
			sizes of 4 main arrays
split int t(0);char s(0),d(0) [
 int y,ix,tx,sl,ds;
 ...
 t(y=y+1)=s+tx;   /* EQERR, =s+tx, ^under x */

debug new commands...
v toggles verbose
Verbose should go to stderr, and be redirectable to a file, and that can be a setting option, default ./verbose.

A restart needs tcMain refactored, separating read files, init globals, link, run. Restart does just the last 3.
---------------------

Mon, Feb 5
CODED: (tc-db) v toggles verbosity. 
Future v p, v e, others for selective tracing. 
	But need to design multiple selects.
	v toogle needs to print on/off
	stack push/pop needs to say what symbol
	indenting would be nice
	whatHappened could print some params
New debug commands implemented yesterday/today
	t <sym>		show symbol type
	v			toggle verbose mode
	q			synonym for x (exit,quit)
10 verboses, too many. It prints TONS. Turning it on for one statement prints 3 or 4 screen-loads.
---------------------

Tue, Feb 6
Need to implement v param to narrow verbosity. Step 1 is survey existing stuff. 
x	71		eq					e 0
x	1110	link				l 1
x	165		toptoi				s 2
x	194		pushst				s 
x	215		popst				s 
x	1170	dumpStackEntry		s 
x	301		symname				t 3
x	353,368,382		konst		t 

Step 2 is design a param tool easy to test.
in tc.h
x	#define VE 0
x	#define VL 1
x	#define VS 2
x	#define VT 3
x	char verbose[8]
10 places, tc.c
x	if(verbose[VE])whatever
in debug.c
x	void verbose_clear() {
x	void verbose_toggle(char* param) {

debug usage & dialog should use printf
NASTY -I/lib BUG, FIXED, did away with the -I, just -w -g, and now have a pure 64 bit version. The -I was a poor attempt to produce a 32 bit version. Never had a proper matching -L, and could not find out how to make one.
---------------------

Wed, Feb 7
Now recovering the modified tc.c, the one with fprintf's.
x	Global replace printf( with fprintf(stderr,  which is overkill
x		logo and whatHappened back to printf's
x		debug dialog is all printf's
x			NEEDS printVar (clone of dumpVar)
x			dumpVar calls PrVal
x				PrVal has 2 uses, and tc.h entry, SHOULD BE dumpVal
x		test outputs all printf's 
x			BUT uses tons of dumps, about 35 or so.
SO: Two subgoals:
x	Get debug -v parm working 
x		DO NOW because almost there.
x			do printVar, don't forget tc.h
x			test
x	Get make dotest working
x		test is now a mix of printf's and dumps. 
x		use fprint's for results, printf's for dialog (if any)
x		make dotest redirects 2> instead of >
TODO debug:
x	v e  printf on/off 
	v - turns off all
	p NULL prints the current line
PROBLEM with regression. Just 2> isn't good enough. Need BOTH to redirect, because a lot of the tests output using ps, pl, etc. Every test needs to end with a flush(stdout) to keep stdout and stderr somewhat synchronized.
With both redirected, Many tests are ok, but quite a few are not.
	< TEST 1  13:57
	---
	> TEST 1  06:36
	13a22,25
	>  var 0: foobaaaz 0 Int 1 pr[51]->0<-
	>  var 1: foobaaaz 0 Int 1 pr[55]->0<-
	>  var 2: foobaaaz 0 Int 1 pr[59]->0<-
	>  var 3: foobaaaz 0 Int 1 pr[63]->0<-
	16c28
	< TEST 2  13:57
	---
	> TEST 2  06:36
	18a31,34
	>  var 0: foob5678 0 Int 1 pr[21]->0<-
	>  var 1: foob5678 0 Int 1 pr[25]->0<-
	>  var 2: foob5678 0 Int 1 pr[29]->0<-
	>  var 3: foob5678 0 Int 1 pr[33]->0<-
	21c37
	< TEST 3  13:57
	---
	> TEST 3  06:36
	23a40,43
	>  var 0: foob 0 Int 1 pr[21]->0<-
	>  var 1: foob 0 Int 1 pr[25]->0<-
	>  var 2: foob 0 Int 1 pr[29]->0<-
	>  var 3: foob 0 Int 1 pr[33]->0<-
	26c46
	< TEST 4  13:57
Just a sample. The > lines disappeared from the test results.
Lets add fflush(stdout); after these prints.
Done, but stuff from dumps is not making it. Some is, some gets lost. Best guess what is happening is that the merger into the file has collisions, and stuff gets lost. If so we cannot use TWO redirects in one file but must find a way to get regression info from two sources in a human checkable way.
Redirect to 2 files with design that allows easy correlation. E.g. TEST 4 <time> sent to BOTH files.
This is gonna take some work. Why not push the debug stuff, and email w/ att debugExample doc to Lee. Is it solid enough?
TOMMOROW: test lee's orig with split, and -v s the line I needed to examine before, line 14 I think. And play with it a bit more. 
TONIGHT: try two file redirection...
	makefile changes, 
x		stderr goes to dump_results
		keep
		diff
x	duplicate headers (TEST ...) one to each stream
	optional, write a bash program to do a merge of these two streams
WORKS so far, two files look good. If I keep two good results and do two diffs will that be humanly nice to use. Avoids the optional merger. Lets go down that road a bit further. We need new file names. DONE...
	good_dump_results, good_test_results
	Never have to type these names, and still handy to ls *ults. 
Next goal: make keep, make diff

Alternative worth examining: everything to stderr. 
	Leave two files for awhile.
	Back up test.c
		audit test_results. What prints/ps/pl should be fprints.
		change these to fprints
		Run regression, less test_results
	Rinse and repeat until test_results has nothing
	Then audit dump_results against expected results in comments.
	If OK erase
		erase test_results (essentially empty by now)
		rename dump to test_results
	Else fix whatever, loop until OK
	make diff
	If all is kool we still have a one file solution
ABANDON, see next...
---------------------

Thur, Feb 8
ISSUE with alternative. When the tc code under test calls ps,pl, or the test case code calls whatHappened, it goes to stdout. So we still have need of two files.
Go with plan A, two files, test.c writes to stdout.
Status, 
x	Producing 2 files. 
x	Got 2 dump headers fixed, stack and varTab
x	Auditing test results (stdout) for other stuff from dumps
x	good results now in testFiles directory
x	make dotest works
x	make difft, make diffd work
x	make keep works

COMMITed, PUSHed

What next? Status, 
	improved debug, 
	improved stderr/stdout separation,
	new doc debug example,
	file cleanup (some)
	more reliable compilation
		maybe FileRead no longer needed???
TODO 
	debug:
		v - turns off all
		p NULL prints the current line
	lib:
		strcat
		read/write file
		printf
		varargs
	doc:
		audit main doc vs Archive/todo.txt writing ideas
		in Archive, move to Doc..
			debug.txt (needs update)
			q
	tidy:
		put each structure in own file, object style
			reduce tc.h to JUST the publics
	interpreter:
		//
		malloc's/settings
		multi-libs
		
Of the above, which is priority???
	0 - strcat
	1 - malloc/settings
	2 - doc stuff
---------------------

Fri, Feb 9
debug funnies...
The t causes a br_hit in _addrval. That feedback loop is probably the problem.
	Can we turn off debug befoe calling addrval and turn it back on afterwards?
	wrapper: addrval_nohit, called in 3 places DONE Tested
FIXED. COMMITED. PUSHED.
---------------------

Sat, Feb 10
Issue, tcc compile fails.  
	ALL CLEAN NOW, committed, pushed.

Goal: strcat, and get Lee's latest to work.
	






