debug
---
To use the debugger, start tinyC with the -d option:
	$ tinyC -d <filename>
You will get a debug prompt
	(db-tc)
The commands are single letters, space (optional), arg (for some commands)
b <symbol>
	set a breakpoint at the in-scope symbol. NOTE: the symbol must be in canonical form, first seven letters plus the last.
i [b]
	information: currently only a list of breakpoints and their state
r
	run the program from the beginning. If already running a query must confirm.
p <variable>
	print the value of the in scope variable
n
	next statement.
c
	continue running to next breakpoint.
x
	exit the interpreter, printing the final status.
g
	go to debugger under which the interpreter is running, e.g. to (gdb). See the section documenting this feature. Used to find interpreter bugs.

Usage notes
This tiny debugger is motivated by my experience with gnu's C/C++ debug, gdb. Seven commands mimic those of gdb, but there are differences.
Breakpoints are set on symbols that must be in scope. That usually means globals, but locals provided their declaration has been process. All function names are global, so they can always be breakpointed. Any occurance of that symbol causes the debugger to be entered before the symbol is processed. The prompt (db-tc) is displayed and you can enter any of the above commands. Use the c command to continue running. Currently the r command also continues running but it should offer a query to restart.
Information with or without the b argument prints a table of current breakpoints. Note that a breakpoint on a local that goes out of scope will disappear from the table. It will not reappear if the function is re-entered, and if needed must be reset. CURRENTLY enabled is always 'y' (yes). CURRENTLY hits are not counted. CURRENTLY the v option (print names of in-scope variables) is unavailable.
Print a variable is probably the most useful command. Its value is displayed. CURRENTLY arrays are fully printed, so it is best to keep their dimensions small until debugging is complete.
Run starts or continues the already loaded tinyC program. No argument is needed. Currently it does not offer the restart option, so a second use of r does a continue.
Next does the next statement. This differs from gdb which does the next line with an executable. The interpreter is statement oriented, not line oriented.
Continue continues execution until another break occurs, or the program ends. If the program ends on an error it is printed, and the interpreter exits.
Exit (x) terminates interpreter execution.

