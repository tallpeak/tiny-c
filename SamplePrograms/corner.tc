#include pyGraphicsLib.tc
#include pps/library.tc

//corner.tc  --  Using last lines direction computes a new direction 
//		given +/- degrees. Draws nothing. Returns a point.
// Example: Draws an arrowhead
//		moveto 10,10
//		lineto 20,20
//		corner (rtx, 135, 5)  <<== not coded yet, 
//		corner (ltx, -135, 5)  <<== probably needs tan
//		lineto rtx(0), rtx(1)
//		moveto 20,20
//		lineto ltx(0), ltx(1)
// But corner90 does a rt angle turn left or right, no trig used.

// returns the largest magnitude
xmaglargest int x,y [
	if(x<0)x=-x
	if(y<0)y=-y
	if(x>y)return x
	else return y
]
// returns the smallest magnitude
xmagsmallest int x,y [
	if(x<0)x=-x
	if(y<0)y=-y
	if(x>y)return y
	else return x
]
// return approximate distance between 2 points
alen  int x0,y0, x1,y1 [
	int len,dx,dy
	dx=x1-x0; dy=y1-y0
	len = asqrt(dx*dx+dy*dy)
	return len
]

// returns an int approximation to sqrt. Uses Newton's method.
asqrt int x[
	int x0,x1,i
	x = x*100  // for precision
	x0 = 1000
	i = 11
	while(i=i-1) [
		x1 = x0-(x0*x0-x)/(2*x0)
		if(x0==x1)break
		x0 = x1
	]
	return (x1+5)/10
]
// turn right/left 90 degrees, return target point for lineto 
// of equal length in ix(0),ix(1). Returns approximate len.
// THE CORNER90 MATH
// Given the prior lines start and end points (captured
// as lastmoveto and lastlineto) exchange the numerator
// and denominator for the new slope. One of these must 
// change sign. If the new direction is towards the upper
// left or lower right, change the numerator, else the 
// denominator. The result is a delta direction. Add the
// delta to the current position and return that point.
// WARNING: not hardened against vert or horz lines
corner90 int ix(1), rl [
	int x0, y0, x1, y1, dx, dy, r, temp
	x0=lastmoveto(0); y0=lastmoveto(1)
	x1=lastlineto(0); y1=lastlineto(1)
		//if(dbg)[pn x1;pn y1]
		//if(dbg)[pl"x0 y0 x1 y1 ="; pn x0; pn y0; pn x1; pn y1]
	dx=x1-x0; dy=y1-y0
	r=dx/dy
		//if(dbg)[ps"   last dx dy r =";pn dx;pn dy;pn r]
	temp=dy  // invert x,y into new direction
	dy=dx
	dx=temp
		//if(dbg)[ps"      rl="; pn rl]
	if(rl>0)[   // right turn sign switch
		if(r>0)dy= -dy
		else dx= -dx
	]
	else [   // left turn
		if(r>0)dx= -dx
		else dy = -dy
	]
		//if(dbg)[pl "new  dx dy   ="; pn dx;pn dy ]
	ix(0) = dx+x1  // return point 1 plus new delta
	ix(1) = dy+y1
		if(dbg)[
			if(rl>0)pl"rt ";else pl"lf "
			pn dx;pn dy;pn ix(0);pn ix(1)
		]
	return alen(x0,y0,x1,y1)
]
// calculates
rt90 int ix(1)[ return corner90 ix, +1 ]
lf90 int ix(1)[ return corner90 ix, -1 ]
// draws
lf [int ix(1), len; len = lf90 ix; lineto ix(0),ix(1) ]
rt [int ix(1), len; len = rt90 ix; lineto ix(0),ix(1) ]

// THREE mains. xmain two of them to run the third.
xmain[
	int ix(1),len
	start "test", 380,300
dbg=0
				if(dbg)[
					ps"seed line from 210 10 to 220 60"
					pl"    dx   dy   x   y"
				]
// seed line plus 3 more
	moveto 120,80
	lineto 170,70
	lf;rt;rt
if(1)[
	lf;rt;rt;lf;rt;rt;
				if(dbg)[arc(180,120,5,0,360);pl"1"]
	lf;rt;lf;lf;rt;lf;
				if(dbg)[arc(40,200,5,0,360);pl"2"]
	lf;rt;lf;lf;rt;rt;
				if(dbg)[arc(200,220,5,0,360);pl"3"]
	lf;rt;lf;lf;rt;lf;
				if(dbg)[arc(340,140,5,0,360);pl"4"]
lf;rt
]
	show
]

// various asqrt tests (a because it is approximate)
xmain [
	int x,y
	y=asqrt(x=612)
	pl"sqrt of"; pn x; ps" is" pn y
	y=asqrt(x=99)
	pl"sqrt of"; pn x; ps" is" pn y
	y=asqrt(x=4612)
	pl"sqrt of"; pn x; ps" is" pn y
	y=asqrt(x=20612)
	pl"sqrt of"; pn x; ps" is" pn y
	y=asqrt(x=32000)
	pl"sqrt of"; pn x; ps" is" pn y
	y=asqrt(x=1000000)
	pl"sqrt of"; pn x; ps" is" pn y
	y=asqrt(x=500000)
	pl"sqrt of"; pn x; ps" is" pn y
]

// various alen tests. len uses asqrt.
main [
	int  x1,y1,length
	x1=40
	y1=0
	pl"right edge from 0,0"
	while(y1<=30)[
		length=alen(0,0,x1,y1)
		pl"x1,y1,length";pn x1;pn y1;pn length
		y1 = y1+10
	]
	pl"bottom"
	while(x1>0)[
		length=alen(0,0,x1,y1)
		pl"x1,y1,length";pn x1;pn y1;pn length
		x1 = x1-10
	]
	pl"";pl"left edge from 40,40"
	while(y1>0)[
		length=alen(40,40,x1,y1)
		pl"x1,y1,length";pn x1;pn y1;pn length
		y1 = y1-10
	]
	pl"top"
	while(x1<=40)[
		length=alen(40,40,x1,y1)
		pl"x1,y1,length";pn x1;pn y1;pn length
		x1 = x1+10
	]
]
