// math about cairo lines
// This lib does not draw. It has computational aids.

//manefest constants, tc style:
SIZE_INT[return 4]
INFINITY[return 2147483647]

// Turn 90 degree corners
corner90 int ix(1), rl [
	int x0, y0, x1, y1, dx, dy, r, temp
	x0=lastmoveto(0); y0=lastmoveto(1)
	x1=lastlineto(0); y1=lastlineto(1)
	dx=x1-x0; dy=y1-y0
	r=dx/dy
	temp=dy  // invert x,y into new direction
	dy=dx
	dx=temp
	if(rl>0)[   // right turn sign switch
		if(r>0)dy= -dy
		else dx= -dx
	]
	else [   // left turn
		if(r>0)dx= -dx
		else dy = -dy
	]
		//if(dbg)[pl "new  dx dy   ="; pn dx;pn dy ]
	ix(0) = dx+x1  // return point 1 plus new delta
	ix(1) = dy+y1
	return alen(x0,y0,x1,y1)
]
// convenience routines
rt90 int ix(1)[ return corner90 ix, +1 ]
lf90 int ix(1)[ return corner90 ix, -1 ]

// Extend a line segment

// computes a point ix that would extend a line segment
// to length len. Positive len extends from the lines end,
// negative from the lines beginning. seg is not modified.
extend int ix(1), seg(3), len [
		int dbg;dbg=0
			if(dbg)[
				pl"   ~150 in extend: "
				psegment seg;ps" len";pn len
			]
	int slen, fac
	slen = seglen(seg)
	if(len>0)fac = 1+len/slen
	else fac = -1+len/slen
			if(dbg)[
				pl"~159 len,fac";pn len;pn fac
			]
	_extend ix,seg,fac
	if(fac>0)[
		seg(2)=ix(0)
		seg(3)=ix(1)
		if(dbg)[pl"~165 new last point"; ppoint seg+2*SIZE_INT]
	]
	else if(fac<0)[
		seg(0)=ix(0)
		seg(1)=ix(1)
		if(dbg)[pl"~159 new first point"; ppoint seg]
	]
	slen = seglen seg
			if(dbg)[
				pl"new seg";psegment seg;ps" slen";pn slen
				pl"";pl"~172 calling trim"; 
			]
			if(dbg)[pl"~178: len slen";pn len;pn slen]
	if(len>0)[
	_trim ix,seg,slen-len
		seg(2)=ix(0)
		seg(3)=ix(1)
		if(dbg)[pl"~165 new last point"; ppoint seg+2*SIZE_INT]
	]
	else if(len<0)[
	_trim ix,seg,-slen-len
		seg(0)=ix(0)
		seg(1)=ix(1)
		if(dbg)[pl"~159 new first point"; ppoint seg]
	]
]

// compute point ix that would extend seg's length by a factor,
// fac. Positive fac extends the lines end, negative the 
// beginning. seg is not modified.
_extend int ix(1), seg(3), fac [
		int dbg;dbg=0
			if(dbg)[pl"   ~7(ex): fac";pn fac]
	int mfac, dx, dy
	if(fac>0)mfac=fac; else mfac=-fac
			if(dbg)[pl"   ~9(ex): mfac";pn mfac]
	dx = (seg(2)-seg(0))*mfac
	dy = (seg(3)-seg(1))*mfac
			if(dbg)[pl"   ~11: dx,dy";pn dx;pn dy]
	if(fac>0)[
		ix(0) = seg(0)+dx
		ix(1) = seg(1)+dy
	] else [
		ix(0) = seg(2)-dx
		ix(1) = seg(3)-dy
	]
			if(dbg)[pl"   ~21: ix ";ppoint ix]
			if(dbg)[pl"   _extend done";pl""]
]

// if length of seg>mag(len) return in ix a new point that would 
// trim to mag(len) seg's length. Trim from seg(2..3) if len>0, 
// else seg(0..1). seg is not modified.

_trim int ix(1),seg(4),len [
		int dbg;dbg=0
	int slen, amt, dx, dy
	dx = seg(2)-seg(0)
	dy = seg(3)-seg(1)
			if(dbg)[pl"   ~32(tr): dx,dy";pn dx;pn dy]
	slen = seglen(seg)
	if(len>0)[
		amt = (1000*len+500)/slen
			if(dbg)[pl"   ~36: len,slen,amt";
				pn len;pn slen;pn amt ]
		ix(0) = seg(2) - amt*dx/1000
		ix(1) = seg(3) - amt*dy/1000
	]
	else[
		amt = (-1000*len-500)/slen
			if(dbg)[pl"   len,slen,amt";pn len;pn slen;pn amt]
		ix(0) = seg(0) + amt*dx/1000
		ix(1) = seg(1) + amt*dy/1000
	]
]

// sets a segment array, seg, with two points
setsegment int seg(3), ax,ay,bx,by [
	seg(0)=ax; seg(1)=ay; seg(2)=bx; seg(3)=by;
]

// prints a segment in brackets
psegment int seg(3) [
	ps"["; ppoint seg; ppoint seg+2*SIZE_INT; ps"]"
]

// prints a point in brackets
ppoint int pt(1) [
	ps"["; pn pt(0); pn pt(1); ps"]"
]

// returns the length of a segment
seglen int seg(3) [
	return alen seg(0),seg(1),seg(2),seg(3)
]

// intersection of two lines
// args: answer, line a, line b
// returns: -1 for parallel lines, 0 for OK
xersect int ix(1), ax0,ay0,ax1,ay1, bx0,by0,bx1,by1 
[
		  int xdb;xdb=0
          if(xdb)[pl"line a ="; pn ax0;pn ay0;pn ax1;pn ay1]
          if(xdb)[pl"line b ="; pn bx0;pn by0;pn bx1;pn by1]
    int day,dax,dby,dbx,f,e,h,g,y,x,avert,bvert
    dax = ax1-ax0
    day = ay1-ay0
    dbx = bx1-bx0
    dby = by1-by0
        if(xdb)[pl"dax,day,dbx,dby";pn dax;pn day;pn dbx;pn dby]
    if(dax==0) [  // line a is vertical
      if(dbx==0) return -1  // parallel
      x = ax0
      avert=1
          if(xdb)[pl"a is vertical at x ="; pn x]
      f=INFINITY    // a slope hopefully never encountered
    ]
    else [
      f = day*1000/dax        //slope
      e = ay0 - f*ax0/1000    // y=0 intersept
          if(xdb)[pl"a: y=fx+e  f,e="; pn f;pn e]
    ]
    if(dbx==0) [  // line b is vertical
      x = bx0
      bvert=1
          if(xdb)[pl"b is vertical at x ="; pn x]
    ]
    else [
      h = dby*1000/dbx
      g = by0 - h*bx0/1000
          if(xdb)[pl"b: y=hx+g ="; pn h;pn g]
      if(h==f)return -1;    // parallel
    ]

    if( 0==(avert+bvert) ) x = ((e-g)*1000)/(h-f)
          if(xdb)[pl"x ="; pn x]

    if( 0==bvert ) y = g + h*x/1000
    else y = e + f*x/1000
          if(xdb)[pl"bvert y ="; pn bvert;pn y]

    ix(0) = x
    ix(1) = y
          if(xdb)[pl"intersect is at "; ppoint ix]
    return 0
]

// set a point bsect that bisects the angle between sega,segb.
// assumes the angle is defined by sega's first point, the
// intersection, and segb's last point. The returned point has
// distance 1000 from the intersection.
bisect int bsect(1), sega(3),segb(3) [
		int dbg; dbg=0
	int xret, icntr(1), segin(3),segout(3), ptout(1),ptin(1)
	xret = xersect icntr,sega(0),sega(1),sega(2),sega(3),segb(0),segb(1),segb(2),segb(3)
	if(xret)return xret   // parallel, no angle
	bisectpts bsect, sega(0),sega(1),icntr(0),icntr(1),segb(2),segb(3)
]

// assign p1=p2
assignpt int p1(1), p2(1)[
	p1(0)=p2(0)
	p1(1)=p2(1)
]
// swap two points
swappt int p1(1), p2(1)[
	int temp(1)
	assign temp,p1
	assign p1,p2
	assign p2,temp
]

// set n=nearest and f=furthest from ii points of seg
// return 0 if ii is between n and f, else +1 for nearest
// is segs end or -1 if its beginning
nearfar int n(1), f(1), ii(1), seg(3)[
	int len1, len2
	len1 = alen ii(0),ii(1),seg(0),seg(1)
	len2 = alen ii(0),ii(1),seg(2),seg(3)
	if(len1>len2)[
		assign f,seg
		assign n,seg+2*SIZE_INT
		which = +1
	] else [
		assign n,seg
		assign f,seg+2*SIZE_INT
		which = -1
	]
	if(len1+len2==(seglen(seg)) return 0 // NOT QUITE ROBUST
	else return which
]

// test that three pts are roughly colinear. Return 0 if not,
// else 1,2,3 to indicate which is in the middle. Return -1 if
// points are tightly clustered. NEEDS TESTING.
colinear int p1(1),p2(1),p3(1)[
	int d12, d13, d23, dlargest
	d12=distance p1,p2
	d13=distance p1,p3
	d23=distance p2,p3
	dlargest=d12; middle=3; dsum=d13+d23
	if(d13>dlargest)[ dlargest = d13; middle = 2; dsum=d12+d23 ]
	if(d23>dlargest)[ dlargest = d23; middle = 1; dsum=d12+d13 ]
	if(dlargest<2) return -1  // tightly clustered
	ddiff = dsum-dlargest
	if((-1<ddiff)*(ddiff<+1))return middle
	return 0
]

// Return true if two segments are parallel
parallel int a(3),b(3) [
	return _parallel a(0),a(1),a(2),a(3),b(0),b(1),b(2),b(3)
]
_parallel int ax0,ay0,ax1,ay1, bx0,by0,bx1,by1 [
    int day,dax,dby,dbx,aslope,bslope
    dax = ax1-ax0; day = ay1-ay0; dbx = bx1-bx0; dby = by1-by0
    if(dax==0) [             // a vertical, 
    	if(dbx==0) return 1      // both vertical
    	else return 0            // b slopes
    ] else [                 // a slopes
    	if(dbx==0) return 0      // b vertical
    ]
    aslope = 1000*day/dax; bslope = 1000*dby/dbx  // both slope
    if(aslope==bslope) return 1         // parallel
    return 0
]

// given 3 points, begin,middle,end, set the point bsect to
// bisect the angle at middle. NOT ROBUST yet for nearly but not quite parallel.
bisectpts int bsect(1), b0,b1,m0,m1,e0,e1 [
		int dbg;dbg=1
	int segin(3), segout(3), ptout(1),ptin(1)
	setsegment segin, m0,m1,b0,b1  //middle outwards
	setsegment segout, m0,m1,e0,e1
		if(dbg)[pl"    segin,segout";psegment(segin);psegment(segout)]
	if(parallel(segin,segout)) return -1
	extend ptin,  segin,  500
	extend ptout, segout, 500
		if(dbg)[pl"    ptin,ptout";ppoint(ptin);ppoint(ptout)]
	bsect(0) = (ptout(0)+ptin(0))/2
	bsect(1) = (ptout(1)+ptin(1))/2
	return 0
]
