// math about cairo lines
// This lib does not draw. It has computational aids.

//manefest constants, tc style:
SIZE_INT[return 4]
INFINITY[return 2147483647]

// Turn 90 degree corners
corner90 int ix(1), rl [
	int x0, y0, x1, y1, dx, dy, r, temp
	x0=lastmoveto(0); y0=lastmoveto(1)
	x1=lastlineto(0); y1=lastlineto(1)
	dx=x1-x0; dy=y1-y0
	r=dx/dy
	temp=dy  // invert x,y into new direction
	dy=dx
	dx=temp
	if(rl>0)[   // right turn sign switch
		if(r>0)dy= -dy
		else dx= -dx
	]
	else [   // left turn
		if(r>0)dx= -dx
		else dy = -dy
	]
		//if(dbg)[pl "new  dx dy   ="; pn dx;pn dy ]
	ix(0) = dx+x1  // return point 1 plus new delta
	ix(1) = dy+y1
	return alen(x0,y0,x1,y1)
]
// convenience routines
rt90 int ix(1)[ return corner90 ix, +1 ]
lf90 int ix(1)[ return corner90 ix, -1 ]

// Extend a line segment

// computes a point ix that would extend a line segment
// to length len. Positive len extends from the lines end,
// negative from the lines beginning. seg is not modified.
extend int ix(1), seg(3), len [
		int dbg;dbg=0
			if(dbg)[
				pl"   ~150 in extend: "
				psegment seg;ps" len";pn len
			]
	int slen, fac
	slen = seglen(seg)
	if(len>0)fac = 1+len/slen
	else fac = -1+len/slen
			if(dbg)[
				pl"~159 len,fac";pn len;pn fac
			]
	_extend ix,seg,fac
	if(fac>0)[
		seg(2)=ix(0)
		seg(3)=ix(1)
		if(dbg)[pl"~165 new last point"; ppoint seg+2*SIZE_INT]
	]
	else if(fac<0)[
		seg(0)=ix(0)
		seg(1)=ix(1)
		if(dbg)[pl"~159 new first point"; ppoint seg]
	]
	slen = seglen seg
			if(dbg)[
				pl"new seg";psegment seg;ps" slen";pn slen
				pl"";pl"~172 calling trim"; 
			]
			if(dbg)[pl"~178: len slen";pn len;pn slen]
	if(len>0)[
	_trim ix,seg,slen-len
		seg(2)=ix(0)
		seg(3)=ix(1)
		if(dbg)[pl"~165 new last point"; ppoint seg+2*SIZE_INT]
	]
	else if(len<0)[
	_trim ix,seg,-slen-len
		seg(0)=ix(0)
		seg(1)=ix(1)
		if(dbg)[pl"~159 new first point"; ppoint seg]
	]
]

// compute point ix that would extend seg's length by a factor,
// fac. Positive fac extends the lines end, negative the 
// beginning. seg is not modified.
_extend int ix(1), seg(3), fac [
		int dbg;dbg=0
			if(dbg)[pl"   ~7(ex): fac";pn fac]
	int mfac, dx, dy
	if(fac>0)mfac=fac; else mfac=-fac
			if(dbg)[pl"   ~9(ex): mfac";pn mfac]
	dx = (seg(2)-seg(0))*mfac
	dy = (seg(3)-seg(1))*mfac
			if(dbg)[pl"   ~11: dx,dy";pn dx;pn dy]
	if(fac>0)[
		ix(0) = seg(0)+dx
		ix(1) = seg(1)+dy
	] else [
		ix(0) = seg(2)-dx
		ix(1) = seg(3)-dy
	]
			if(dbg)[pl"   ~21: ix ";ppoint ix]
			if(dbg)[pl"   _extend done";pl""]
]

// if length of seg>mag(len) return in ix a new point that would 
// trim to mag(len) seg's length. Trim from seg(2..3) if len>0, 
// else seg(0..1). seg is not modified.

_trim int ix(1),seg(4),len [
		int dbg;dbg=0
	int slen, amt, dx, dy
	dx = seg(2)-seg(0)
	dy = seg(3)-seg(1)
			if(dbg)[pl"   ~32(tr): dx,dy";pn dx;pn dy]
	slen = seglen(seg)
	if(len>0)[
		amt = (1000*len+500)/slen
			if(dbg)[pl"   ~36: len,slen,amt";
				pn len;pn slen;pn amt ]
		ix(0) = seg(2) - amt*dx/1000
		ix(1) = seg(3) - amt*dy/1000
	]
	else[
		amt = (-1000*len-500)/slen
			if(dbg)[pl"   len,slen,amt";pn len;pn slen;pn amt]
		ix(0) = seg(0) + amt*dx/1000
		ix(1) = seg(1) + amt*dy/1000
	]
]

// sets a segment array, seg, with two points
setsegment int seg(3), ax,ay,bx,by [
	seg(0)=ax; seg(1)=ay; seg(2)=bx; seg(3)=by;
]

// prints a segment in brackets
psegment int seg(3) [
	ps"["; ppoint seg; ppoint seg+2*SIZE_INT; ps"]"
]

// prints a point in brackets
ppoint int pt(1) [
	ps"["; pn pt(0); pn pt(1); ps"]"
]

// returns the length of a segment
seglen int seg(3) [
	return alen seg(0),seg(1),seg(2),seg(3)
]

// intersection of two lines
// args: answer, line a, line b
// returns: -1 for parallel lines, 0 for OK
xersect int ix(1), ax0,ay0,ax1,ay1, bx0,by0,bx1,by1 
[
		  int xdb;xdb=0
          if(xdb)[pl"line a ="; pn ax0;pn ay0;pn ax1;pn ay1]
          if(xdb)[pl"line b ="; pn bx0;pn by0;pn bx1;pn by1]
    int day,dax,dby,dbx,f,e,h,g,y,x,avert,bvert
    dax = ax1-ax0
    day = ay1-ay0
    dbx = bx1-bx0
    dby = by1-by0
        if(xdb)[pl"dax,day,dbx,dby";pn dax;pn day;pn dbx;pn dby]
    if(dax==0) [  // line a is vertical
      if(dbx==0) return -1  // parallel
      x = ax0
      avert=1
          if(xdb)[pl"a is vertical at x ="; pn x]
      f=INFINITY    // a slope hopefully never encountered
    ]
    else [
      f = day*1000/dax        //slope
      e = ay0 - f*ax0/1000    // y=0 intersept
          if(xdb)[pl"a: y=fx+e  f,e="; pn f;pn e]
    ]
    if(dbx==0) [  // line b is vertical
      x = bx0
      bvert=1
          if(xdb)[pl"b is vertical at x ="; pn x]
    ]
    else [
      h = dby*1000/dbx
      g = by0 - h*bx0/1000
          if(xdb)[pl"b: y=hx+g ="; pn h;pn g]
      if(h==f)return -1;    // parallel
    ]

    if( 0==(avert+bvert) ) x = ((e-g)*1000)/(h-f)
          if(xdb)[pl"x ="; pn x]

    if( 0==bvert ) y = g + h*x/1000
    else y = e + f*x/1000
          if(xdb)[pl"bvert y ="; pn bvert;pn y]

    ix(0) = x
    ix(1) = y
          if(xdb)[pl"intersect is at "; ppoint ix]
    return 0
]
